"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design";
exports.ids = ["vendor-chunks/@paper-design"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorPropsAreEqual: () => (/* binding */ colorPropsAreEqual)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction colorPropsAreEqual(prevProps, nextProps) {\n  for (const key in prevProps) {\n    if (key === \"colors\") {\n      const prevIsArray = Array.isArray(prevProps.colors);\n      const nextIsArray = Array.isArray(nextProps.colors);\n      if (!prevIsArray || !nextIsArray) {\n        if (Object.is(prevProps.colors, nextProps.colors) === false) {\n          return false;\n        }\n        continue;\n      }\n      if (prevProps.colors?.length !== nextProps.colors?.length) {\n        return false;\n      }\n      if (!prevProps.colors?.every((color, index) => color === nextProps.colors?.[index])) {\n        return false;\n      }\n      continue;\n    }\n    if (Object.is(prevProps[key], nextProps[key]) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=color-props-are-equal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3lvZ2VzaC9Eb2N1bWVudHMvWW9nZXNoSzM0LmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5mdW5jdGlvbiBjb2xvclByb3BzQXJlRXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldlByb3BzKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjb2xvcnNcIikge1xuICAgICAgY29uc3QgcHJldklzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByZXZQcm9wcy5jb2xvcnMpO1xuICAgICAgY29uc3QgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHRQcm9wcy5jb2xvcnMpO1xuICAgICAgaWYgKCFwcmV2SXNBcnJheSB8fCAhbmV4dElzQXJyYXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5pcyhwcmV2UHJvcHMuY29sb3JzLCBuZXh0UHJvcHMuY29sb3JzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJldlByb3BzLmNvbG9ycz8ubGVuZ3RoICE9PSBuZXh0UHJvcHMuY29sb3JzPy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFwcmV2UHJvcHMuY29sb3JzPy5ldmVyeSgoY29sb3IsIGluZGV4KSA9PiBjb2xvciA9PT0gbmV4dFByb3BzLmNvbG9ycz8uW2luZGV4XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChPYmplY3QuaXMocHJldlByb3BzW2tleV0sIG5leHRQcm9wc1trZXldKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQge1xuICBjb2xvclByb3BzQXJlRXF1YWxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci1wcm9wcy1hcmUtZXF1YWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shader-mount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\");\n/* harmony import */ var _use_merge_refs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-merge-refs.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */ /* __next_internal_client_entry_do_not_use__ ShaderMount auto */ \n\n\n\nasync function processUniforms(uniformsProp) {\n    const processedUniforms = {};\n    const imageLoadPromises = [];\n    const isValidUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return true;\n            new URL(url);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    const isExternalUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return false;\n            const urlObject = new URL(url, window.location.origin);\n            return urlObject.origin !== window.location.origin;\n        } catch  {\n            return false;\n        }\n    };\n    Object.entries(uniformsProp).forEach(([key, value])=>{\n        if (typeof value === \"string\") {\n            if (!isValidUrl(value)) {\n                console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n                return;\n            }\n            const imagePromise = new Promise((resolve, reject)=>{\n                const img = new Image();\n                if (isExternalUrl(value)) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                img.onload = ()=>{\n                    processedUniforms[key] = img;\n                    resolve();\n                };\n                img.onerror = ()=>{\n                    console.error(`Could not set uniforms. Failed to load image at ${value}`);\n                    reject();\n                };\n                img.src = value;\n            });\n            imageLoadPromises.push(imagePromise);\n        } else {\n            processedUniforms[key] = value;\n        }\n    });\n    await Promise.all(imageLoadPromises);\n    return processedUniforms;\n}\nconst ShaderMount = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function ShaderMountImpl({ fragmentShader, uniforms: uniformsProp, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio, maxPixelCount, ...divProps }, forwardedRef) {\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const divRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shaderMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            const initShader = {\n                \"ShaderMount.ShaderMountImpl.useEffect.initShader\": async ()=>{\n                    const uniforms = await processUniforms(uniformsProp);\n                    if (divRef.current && !shaderMountRef.current) {\n                        shaderMountRef.current = new _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderMount(divRef.current, fragmentShader, uniforms, webGlContextAttributes, speed, frame, minPixelRatio, maxPixelCount);\n                        setIsInitialized(true);\n                    }\n                }\n            }[\"ShaderMount.ShaderMountImpl.useEffect.initShader\"];\n            initShader();\n            return ({\n                \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n                    shaderMountRef.current?.dispose();\n                    shaderMountRef.current = null;\n                }\n            })[\"ShaderMount.ShaderMountImpl.useEffect\"];\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        fragmentShader,\n        webGlContextAttributes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            const updateUniforms = {\n                \"ShaderMount.ShaderMountImpl.useEffect.updateUniforms\": async ()=>{\n                    const uniforms = await processUniforms(uniformsProp);\n                    shaderMountRef.current?.setUniforms(uniforms);\n                }\n            }[\"ShaderMount.ShaderMountImpl.useEffect.updateUniforms\"];\n            updateUniforms();\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        uniformsProp,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setSpeed(speed);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        speed,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        maxPixelCount,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        minPixelRatio,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setFrame(frame);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        frame,\n        isInitialized\n    ]);\n    const mergedRef = (0,_use_merge_refs_js__WEBPACK_IMPORTED_MODULE_3__.useMergeRefs)([\n        divRef,\n        forwardedRef\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: mergedRef,\n        ...divProps\n    });\n});\nShaderMount.displayName = \"ShaderMount\";\n //# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzJIQUV3RDtBQU1qRDtBQUNzQjtBQTBLbEI7QUE3SVgsZUFBZSxnQkFBZ0IsY0FBc0U7SUFDbkcsTUFBTSxvQkFBb0IsQ0FBQztJQUMzQixNQUFNLG9CQUFxQyxDQUFDO0lBRTVDLE1BQU0sYUFBYSxDQUFDO1FBQ2xCLElBQUk7WUFFRixJQUFJLElBQUksV0FBVyxHQUFHLEVBQUcsUUFBTztZQUVoQyxJQUFJLElBQUksR0FBRztZQUNYLE9BQU87UUFDVCxTQUFRO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQSxNQUFNLGdCQUFnQixDQUFDO1FBQ3JCLElBQUk7WUFDRixJQUFJLElBQUksV0FBVyxHQUFHLEVBQUcsUUFBTztZQUNoQyxNQUFNLFlBQVksSUFBSSxJQUFJLEtBQUssT0FBTyxTQUFTLE1BQU07WUFDckQsT0FBTyxVQUFVLFdBQVcsT0FBTyxTQUFTO1FBQzlDLFNBQVE7WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU8sUUFBUSxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUMsS0FBSyxLQUFLO1FBQy9DLElBQUksT0FBTyxVQUFVLFVBQVU7WUFFN0IsSUFBSSxDQUFDLFdBQVcsS0FBSyxHQUFHO2dCQUN0QixRQUFRLEtBQUssWUFBWSxHQUFHLHNCQUFzQixLQUFLLDRCQUE0QjtnQkFDbkY7WUFDRjtZQUVBLE1BQU0sZUFBZSxJQUFJLFFBQWMsQ0FBQyxTQUFTO2dCQUMvQyxNQUFNLE1BQU0sSUFBSSxNQUFNO2dCQUN0QixJQUFJLGNBQWMsS0FBSyxHQUFHO29CQUN4QixJQUFJLGNBQWM7Z0JBQ3BCO2dCQUNBLElBQUksU0FBUztvQkFDWCxrQkFBa0IsR0FBRyxJQUFJO29CQUN6QixRQUFRO2dCQUNWO2dCQUNBLElBQUksVUFBVTtvQkFDWixRQUFRLE1BQU0sbURBQW1ELEtBQUssRUFBRTtvQkFDeEUsT0FBTztnQkFDVDtnQkFDQSxJQUFJLE1BQU07WUFDWixDQUFDO1lBQ0Qsa0JBQWtCLEtBQUssWUFBWTtRQUNyQyxPQUFPO1lBQ0wsa0JBQWtCLEdBQUcsSUFBSTtRQUMzQjtJQUNGLENBQUM7SUFFRCxNQUFNLFFBQVEsSUFBSSxpQkFBaUI7SUFDbkMsT0FBTztBQUNUO0FBTU8sTUFBTSw0QkFBMEMsaURBQVUsQ0FDL0QsU0FBUyxnQkFDUCxFQUNFLGdCQUNBLFVBQVUsY0FDVix3QkFDQSxRQUFRLEdBQ1IsUUFBUSxHQUNSLGVBQ0EsZUFDQSxHQUFHLFVBQ0wsRUFDQSxjQUNBO0lBQ0EsTUFBTSxDQUFDLGVBQWUsZ0JBQWdCLElBQUksK0NBQVEsQ0FBQyxLQUFLO0lBQ3hELE1BQU0sU0FBUyw2Q0FBTSxDQUFxQixJQUFJO0lBQzlDLE1BQU0saUJBQTZELDZDQUFNLENBQXFCLElBQUk7SUFHbEcsZ0RBQVM7aURBQUM7WUFDUixNQUFNO29FQUFhO29CQUNqQixNQUFNLFdBQVcsTUFBTSxnQkFBZ0IsWUFBWTtvQkFFbkQsSUFBSSxPQUFPLFdBQVcsQ0FBQyxlQUFlLFNBQVM7d0JBQzdDLGVBQWUsVUFBVSxJQUFJLDhEQUFrQixDQUM3QyxPQUFPLFNBQ1AsZ0JBQ0EsVUFDQSx3QkFDQSxPQUNBLE9BQ0EsZUFDQTt3QkFHRixpQkFBaUIsSUFBSTtvQkFDdkI7Z0JBQ0Y7O1lBRUEsV0FBVztZQUVYO3lEQUFPO29CQUNMLGVBQWUsU0FBUyxRQUFRO29CQUNoQyxlQUFlLFVBQVU7Z0JBQzNCOztRQUNGO2dEQUFHO1FBQUM7UUFBZ0Isc0JBQXNCO0tBQUM7SUFHM0MsZ0RBQVM7aURBQUM7WUFDUixNQUFNO3dFQUFpQjtvQkFDckIsTUFBTSxXQUFXLE1BQU0sZ0JBQWdCLFlBQVk7b0JBQ25ELGVBQWUsU0FBUyxZQUFZLFFBQVE7Z0JBQzlDOztZQUVBLGVBQWU7UUFDakI7Z0RBQUc7UUFBQztRQUFjLGFBQWE7S0FBQztJQUdoQyxnREFBUztpREFBQztZQUNSLGVBQWUsU0FBUyxTQUFTLEtBQUs7UUFDeEM7Z0RBQUc7UUFBQztRQUFPLGFBQWE7S0FBQztJQUd6QixnREFBUztpREFBQztZQUNSLGVBQWUsU0FBUyxpQkFBaUIsYUFBYTtRQUN4RDtnREFBRztRQUFDO1FBQWUsYUFBYTtLQUFDO0lBR2pDLGdEQUFTO2lEQUFDO1lBQ1IsZUFBZSxTQUFTLGlCQUFpQixhQUFhO1FBQ3hEO2dEQUFHO1FBQUM7UUFBZSxhQUFhO0tBQUM7SUFHakMsZ0RBQVM7aURBQUM7WUFDUixlQUFlLFNBQVMsU0FBUyxLQUFLO1FBQ3hDO2dEQUFHO1FBQUM7UUFBTyxhQUFhO0tBQUM7SUFFekIsTUFBTSxZQUFZLGdFQUFZLENBQUM7UUFBQztRQUFRLFlBQVk7S0FBQztJQUNyRCxPQUFPLHVFQUFDO1FBQUksS0FBSztRQUFZLEdBQUc7SUFBQSxDQUFVO0FBQzVDO0FBR0YsWUFBWSxjQUFjIiwic291cmNlcyI6WyIvaG9tZS95b2dlc2gvRG9jdW1lbnRzL3NyYy9zaGFkZXItbW91bnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgU2hhZGVyTW91bnQgYXMgU2hhZGVyTW91bnRWYW5pbGxhLFxuICB0eXBlIFBhcGVyU2hhZGVyRWxlbWVudCxcbiAgdHlwZSBTaGFkZXJNb3Rpb25QYXJhbXMsXG4gIHR5cGUgU2hhZGVyTW91bnRVbmlmb3Jtcyxcbn0gZnJvbSAnQHBhcGVyLWRlc2lnbi9zaGFkZXJzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJy4vdXNlLW1lcmdlLXJlZnMuanMnO1xuXG4vKipcbiAqIFJlYWN0IFNoYWRlciBNb3VudCBjYW4gYWxzbyBhY2NlcHQgc3RyaW5ncyBhcyB1bmlmb3JtIHZhbHVlcywgd2hpY2ggd2lsbCBhc3N1bWVkIHRvIGJlIFVSTHMgYW5kIGxvYWRlZCBhcyBpbWFnZXNcbiAqXG4gKiBXZSBhY2NlcHQgdW5kZWZpbmVkIGFzIGEgY29udmVuaWVuY2UgZm9yIHNlcnZlciByZW5kZXJpbmcsIHdoZW4gc29tZSB0aGluZ3MgbWF5IGJlIHVuZGVmaW5lZFxuICogV2UganVzdCBza2lwIHNldHRpbmcgdGhlIHVuaWZvcm0gaWYgaXQncyB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSBzaGFkZXIgbW91bnQgdG8gc3RpbGwgdGFrZSB1cCBzcGFjZSBkdXJpbmcgc2VydmVyIHJlbmRlcmluZ1xuICovXG5pbnRlcmZhY2UgU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IG51bWJlcltdIHwgbnVtYmVyW11bXSB8IEhUTUxJbWFnZUVsZW1lbnQgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyTW91bnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+LCBTaGFkZXJNb3Rpb25QYXJhbXMge1xuICByZWY/OiBSZWFjdC5SZWY8UGFwZXJTaGFkZXJFbGVtZW50PjtcbiAgZnJhZ21lbnRTaGFkZXI6IHN0cmluZztcbiAgdW5pZm9ybXM6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdDtcbiAgbWluUGl4ZWxSYXRpbz86IG51bWJlcjtcbiAgbWF4UGl4ZWxDb3VudD86IG51bWJlcjtcbiAgd2ViR2xDb250ZXh0QXR0cmlidXRlcz86IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyQ29tcG9uZW50UHJvcHMgZXh0ZW5kcyBPbWl0PFJlYWN0LkNvbXBvbmVudFByb3BzPCdkaXYnPiwgJ2NvbG9yJyB8ICdyZWYnPiB7XG4gIHJlZj86IFJlYWN0LlJlZjxQYXBlclNoYWRlckVsZW1lbnQ+O1xuICBtaW5QaXhlbFJhdGlvPzogbnVtYmVyO1xuICBtYXhQaXhlbENvdW50PzogbnVtYmVyO1xuICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzPzogV2ViR0xDb250ZXh0QXR0cmlidXRlcztcbn1cblxuLyoqIFBhcnNlIHRoZSBwcm92aWRlZCB1bmlmb3JtcywgdHVybmluZyBVUkwgc3RyaW5ncyBpbnRvIGxvYWRlZCBpbWFnZXMgKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3A6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdCk6IFByb21pc2U8U2hhZGVyTW91bnRVbmlmb3Jtcz4ge1xuICBjb25zdCBwcm9jZXNzZWRVbmlmb3JtcyA9IHt9IGFzIFNoYWRlck1vdW50VW5pZm9ybXM7XG4gIGNvbnN0IGltYWdlTG9hZFByb21pc2VzOiBQcm9taXNlPHZvaWQ+W10gPSBbXTtcblxuICBjb25zdCBpc1ZhbGlkVXJsID0gKHVybDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoc1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiB0cnVlO1xuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHZhbGlkIFVSTFxuICAgICAgbmV3IFVSTCh1cmwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGlzRXh0ZXJuYWxVcmwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgIHJldHVybiB1cmxPYmplY3Qub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBPYmplY3QuZW50cmllcyh1bmlmb3Jtc1Byb3ApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIHZhbGlkIFVSTCBvciBqdXN0IHNraXAgdHJ5aW5nIHRvIHNldCB0aGlzIHVuaWZvcm0gZW50aXJlbHlcbiAgICAgIGlmICghaXNWYWxpZFVybCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmlmb3JtIFwiJHtrZXl9XCIgaGFzIGludmFsaWQgVVJMIFwiJHt2YWx1ZX1cIi4gU2tpcHBpbmcgaW1hZ2UgbG9hZGluZy5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpZiAoaXNFeHRlcm5hbFVybCh2YWx1ZSkpIHtcbiAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgfVxuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIHByb2Nlc3NlZFVuaWZvcm1zW2tleV0gPSBpbWc7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3Qgc2V0IHVuaWZvcm1zLiBGYWlsZWQgdG8gbG9hZCBpbWFnZSBhdCAke3ZhbHVlfWApO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIGltYWdlTG9hZFByb21pc2VzLnB1c2goaW1hZ2VQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzc2VkVW5pZm9ybXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwoaW1hZ2VMb2FkUHJvbWlzZXMpO1xuICByZXR1cm4gcHJvY2Vzc2VkVW5pZm9ybXM7XG59XG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBtb3VudHMgYSBzaGFkZXIgYW5kIHVwZGF0ZXMgaXRzIHVuaWZvcm1zIGFzIHRoZSBjb21wb25lbnQncyBwcm9wcyBjaGFuZ2VcbiAqIElmIHlvdSBwYXNzIGEgc3RyaW5nIGFzIGEgdW5pZm9ybSB2YWx1ZSwgaXQgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIGEgVVJMIGFuZCBhdHRlbXB0ZWQgdG8gYmUgbG9hZGVkIGFzIGFuIGltYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBTaGFkZXJNb3VudDogUmVhY3QuRkM8U2hhZGVyTW91bnRQcm9wcz4gPSBmb3J3YXJkUmVmPFBhcGVyU2hhZGVyRWxlbWVudCwgU2hhZGVyTW91bnRQcm9wcz4oXG4gIGZ1bmN0aW9uIFNoYWRlck1vdW50SW1wbChcbiAgICB7XG4gICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgIHVuaWZvcm1zOiB1bmlmb3Jtc1Byb3AsXG4gICAgICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzLFxuICAgICAgc3BlZWQgPSAwLFxuICAgICAgZnJhbWUgPSAwLFxuICAgICAgbWluUGl4ZWxSYXRpbyxcbiAgICAgIG1heFBpeGVsQ291bnQsXG4gICAgICAuLi5kaXZQcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkge1xuICAgIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBkaXZSZWYgPSB1c2VSZWY8UGFwZXJTaGFkZXJFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBzaGFkZXJNb3VudFJlZjogUmVhY3QuUmVmT2JqZWN0PFNoYWRlck1vdW50VmFuaWxsYSB8IG51bGw+ID0gdXNlUmVmPFNoYWRlck1vdW50VmFuaWxsYT4obnVsbCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBTaGFkZXJNb3VudFZhbmlsbGFcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdFNoYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5pZm9ybXMgPSBhd2FpdCBwcm9jZXNzVW5pZm9ybXModW5pZm9ybXNQcm9wKTtcblxuICAgICAgICBpZiAoZGl2UmVmLmN1cnJlbnQgJiYgIXNoYWRlck1vdW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50ID0gbmV3IFNoYWRlck1vdW50VmFuaWxsYShcbiAgICAgICAgICAgIGRpdlJlZi5jdXJyZW50LFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgbWluUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIG1heFBpeGVsQ291bnRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0SXNJbml0aWFsaXplZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaW5pdFNoYWRlcigpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5kaXNwb3NlKCk7XG4gICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LCBbZnJhZ21lbnRTaGFkZXIsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXNdKTtcblxuICAgIC8vIFVuaWZvcm1zXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZVVuaWZvcm1zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IGF3YWl0IHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3ApO1xuICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRVbmlmb3Jtcyh1bmlmb3Jtcyk7XG4gICAgICB9O1xuXG4gICAgICB1cGRhdGVVbmlmb3JtcygpO1xuICAgIH0sIFt1bmlmb3Jtc1Byb3AsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIFNwZWVkXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldFNwZWVkKHNwZWVkKTtcbiAgICB9LCBbc3BlZWQsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIE1heCBQaXhlbCBDb3VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRNYXhQaXhlbENvdW50KG1heFBpeGVsQ291bnQpO1xuICAgIH0sIFttYXhQaXhlbENvdW50LCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICAvLyBNaW4gUGl4ZWwgUmF0aW9cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0TWluUGl4ZWxSYXRpbyhtaW5QaXhlbFJhdGlvKTtcbiAgICB9LCBbbWluUGl4ZWxSYXRpbywgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gRnJhbWVcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0RnJhbWUoZnJhbWUpO1xuICAgIH0sIFtmcmFtZSwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgY29uc3QgbWVyZ2VkUmVmID0gdXNlTWVyZ2VSZWZzKFtkaXZSZWYsIGZvcndhcmRlZFJlZl0pIGFzIHVua25vd24gYXMgUmVhY3QuUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50PjtcbiAgICByZXR1cm4gPGRpdiByZWY9e21lcmdlZFJlZn0gey4uLmRpdlByb3BzfSAvPjtcbiAgfVxuKTtcblxuU2hhZGVyTW91bnQuZGlzcGxheU5hbWUgPSAnU2hhZGVyTW91bnQnO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/dot-grid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/dot-grid.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DotGrid: () => (/* binding */ DotGrid),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   dotGridPresets: () => (/* binding */ dotGridPresets)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../color-props-are-equal.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/dot-grid.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultPatternSizing,\n    colorBack: \"#15212d\",\n    colorFill: \"#5794ff\",\n    colorStroke: \"#0000ff\",\n    size: 3,\n    gapX: 25,\n    gapY: 25,\n    strokeWidth: 0,\n    sizeRange: 0.25,\n    opacityRange: 0.9,\n    shape: \"circle\"\n  }\n};\nconst trianglesPreset = {\n  name: \"Triangles\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultPatternSizing,\n    colorBack: \"#ffffff\",\n    colorFill: \"#ffffff\",\n    colorStroke: \"#808080\",\n    size: 5,\n    gapX: 32,\n    gapY: 32,\n    strokeWidth: 1,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: \"triangle\"\n  }\n};\nconst treeLinePreset = {\n  name: \"Tree line\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultPatternSizing,\n    colorBack: \"#f4fce7\",\n    colorFill: \"#052e19\",\n    colorStroke: \"#000000\",\n    size: 8,\n    gapX: 20,\n    gapY: 90,\n    strokeWidth: 0,\n    sizeRange: 1,\n    opacityRange: 0.6,\n    shape: \"circle\"\n  }\n};\nconst wallpaperPreset = {\n  name: \"Wallpaper\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultPatternSizing,\n    colorBack: \"#204030\",\n    colorFill: \"#000000\",\n    colorStroke: \"#bd955b\",\n    size: 9,\n    gapX: 32,\n    gapY: 32,\n    strokeWidth: 1,\n    sizeRange: 0,\n    opacityRange: 0,\n    shape: \"diamond\"\n  }\n};\nconst dotGridPresets = [defaultPreset, trianglesPreset, treeLinePreset, wallpaperPreset];\nconst DotGrid = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function DotGridImpl({\n  // Own props\n  colorBack = defaultPreset.params.colorBack,\n  colorFill = defaultPreset.params.colorFill,\n  colorStroke = defaultPreset.params.colorStroke,\n  size = defaultPreset.params.size,\n  gapX = defaultPreset.params.gapX,\n  gapY = defaultPreset.params.gapY,\n  strokeWidth = defaultPreset.params.strokeWidth,\n  sizeRange = defaultPreset.params.sizeRange,\n  opacityRange = defaultPreset.params.opacityRange,\n  shape = defaultPreset.params.shape,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  scale = defaultPreset.params.scale,\n  rotation = defaultPreset.params.rotation,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  // Other props\n  maxPixelCount = 6016 * 3384,\n  // Higher max resolution for this shader\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colorBack: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString)(colorBack),\n    u_colorFill: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString)(colorFill),\n    u_colorStroke: (0,_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString)(colorStroke),\n    u_dotSize: size,\n    u_gapX: gapX,\n    u_gapY: gapY,\n    u_strokeWidth: strokeWidth,\n    u_sizeRange: sizeRange,\n    u_opacityRange: opacityRange,\n    u_shape: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__.DotGridShapes[shape],\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_scale: scale,\n    u_rotation: rotation,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_shader_mount_js__WEBPACK_IMPORTED_MODULE_5__.ShaderMount, { ...props, maxPixelCount, fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_4__.dotGridFragmentShader, uniforms });\n}, _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__.colorPropsAreEqual);\n\n//# sourceMappingURL=dot-grid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9kb3QtZ3JpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRTZCO0FBQ29CO0FBQ2dCO0FBT2xDO0FBQ1M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RUFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RUFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RUFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RUFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGlCQUFpQiwrRUFBd0I7QUFDekMsaUJBQWlCLCtFQUF3QjtBQUN6QyxtQkFBbUIsK0VBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0VBQWE7QUFDMUI7QUFDQSxXQUFXLG1FQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQUcsQ0FBQyx5REFBVyxJQUFJLHlDQUF5Qyx3RUFBcUIsWUFBWTtBQUN0SCxDQUFDLEVBQUUseUVBQWtCO0FBS25CO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3lvZ2VzaC9Eb2N1bWVudHMvWW9nZXNoSzM0LmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9kb3QtZ3JpZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgU2hhZGVyTW91bnQgfSBmcm9tIFwiLi4vc2hhZGVyLW1vdW50LmpzXCI7XG5pbXBvcnQgeyBjb2xvclByb3BzQXJlRXF1YWwgfSBmcm9tIFwiLi4vY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzXCI7XG5pbXBvcnQge1xuICBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcsXG4gIGRvdEdyaWRGcmFnbWVudFNoYWRlcixcbiAgRG90R3JpZFNoYXBlcyxcbiAgU2hhZGVyRml0T3B0aW9ucyxcbiAgZGVmYXVsdFBhdHRlcm5TaXppbmdcbn0gZnJvbSBcIkBwYXBlci1kZXNpZ24vc2hhZGVyc1wiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBkZWZhdWx0UHJlc2V0ID0ge1xuICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdFBhdHRlcm5TaXppbmcsXG4gICAgY29sb3JCYWNrOiBcIiMxNTIxMmRcIixcbiAgICBjb2xvckZpbGw6IFwiIzU3OTRmZlwiLFxuICAgIGNvbG9yU3Ryb2tlOiBcIiMwMDAwZmZcIixcbiAgICBzaXplOiAzLFxuICAgIGdhcFg6IDI1LFxuICAgIGdhcFk6IDI1LFxuICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIHNpemVSYW5nZTogMC4yNSxcbiAgICBvcGFjaXR5UmFuZ2U6IDAuOSxcbiAgICBzaGFwZTogXCJjaXJjbGVcIlxuICB9XG59O1xuY29uc3QgdHJpYW5nbGVzUHJlc2V0ID0ge1xuICBuYW1lOiBcIlRyaWFuZ2xlc1wiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0UGF0dGVyblNpemluZyxcbiAgICBjb2xvckJhY2s6IFwiI2ZmZmZmZlwiLFxuICAgIGNvbG9yRmlsbDogXCIjZmZmZmZmXCIsXG4gICAgY29sb3JTdHJva2U6IFwiIzgwODA4MFwiLFxuICAgIHNpemU6IDUsXG4gICAgZ2FwWDogMzIsXG4gICAgZ2FwWTogMzIsXG4gICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgc2l6ZVJhbmdlOiAwLFxuICAgIG9wYWNpdHlSYW5nZTogMCxcbiAgICBzaGFwZTogXCJ0cmlhbmdsZVwiXG4gIH1cbn07XG5jb25zdCB0cmVlTGluZVByZXNldCA9IHtcbiAgbmFtZTogXCJUcmVlIGxpbmVcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdFBhdHRlcm5TaXppbmcsXG4gICAgY29sb3JCYWNrOiBcIiNmNGZjZTdcIixcbiAgICBjb2xvckZpbGw6IFwiIzA1MmUxOVwiLFxuICAgIGNvbG9yU3Ryb2tlOiBcIiMwMDAwMDBcIixcbiAgICBzaXplOiA4LFxuICAgIGdhcFg6IDIwLFxuICAgIGdhcFk6IDkwLFxuICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIHNpemVSYW5nZTogMSxcbiAgICBvcGFjaXR5UmFuZ2U6IDAuNixcbiAgICBzaGFwZTogXCJjaXJjbGVcIlxuICB9XG59O1xuY29uc3Qgd2FsbHBhcGVyUHJlc2V0ID0ge1xuICBuYW1lOiBcIldhbGxwYXBlclwiLFxuICBwYXJhbXM6IHtcbiAgICAuLi5kZWZhdWx0UGF0dGVyblNpemluZyxcbiAgICBjb2xvckJhY2s6IFwiIzIwNDAzMFwiLFxuICAgIGNvbG9yRmlsbDogXCIjMDAwMDAwXCIsXG4gICAgY29sb3JTdHJva2U6IFwiI2JkOTU1YlwiLFxuICAgIHNpemU6IDksXG4gICAgZ2FwWDogMzIsXG4gICAgZ2FwWTogMzIsXG4gICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgc2l6ZVJhbmdlOiAwLFxuICAgIG9wYWNpdHlSYW5nZTogMCxcbiAgICBzaGFwZTogXCJkaWFtb25kXCJcbiAgfVxufTtcbmNvbnN0IGRvdEdyaWRQcmVzZXRzID0gW2RlZmF1bHRQcmVzZXQsIHRyaWFuZ2xlc1ByZXNldCwgdHJlZUxpbmVQcmVzZXQsIHdhbGxwYXBlclByZXNldF07XG5jb25zdCBEb3RHcmlkID0gbWVtbyhmdW5jdGlvbiBEb3RHcmlkSW1wbCh7XG4gIC8vIE93biBwcm9wc1xuICBjb2xvckJhY2sgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5jb2xvckJhY2ssXG4gIGNvbG9yRmlsbCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmNvbG9yRmlsbCxcbiAgY29sb3JTdHJva2UgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5jb2xvclN0cm9rZSxcbiAgc2l6ZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNpemUsXG4gIGdhcFggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5nYXBYLFxuICBnYXBZID0gZGVmYXVsdFByZXNldC5wYXJhbXMuZ2FwWSxcbiAgc3Ryb2tlV2lkdGggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5zdHJva2VXaWR0aCxcbiAgc2l6ZVJhbmdlID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc2l6ZVJhbmdlLFxuICBvcGFjaXR5UmFuZ2UgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcGFjaXR5UmFuZ2UsXG4gIHNoYXBlID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc2hhcGUsXG4gIC8vIFNpemluZyBwcm9wc1xuICBmaXQgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5maXQsXG4gIHNjYWxlID0gZGVmYXVsdFByZXNldC5wYXJhbXMuc2NhbGUsXG4gIHJvdGF0aW9uID0gZGVmYXVsdFByZXNldC5wYXJhbXMucm90YXRpb24sXG4gIG9yaWdpblggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vcmlnaW5YLFxuICBvcmlnaW5ZID0gZGVmYXVsdFByZXNldC5wYXJhbXMub3JpZ2luWSxcbiAgb2Zmc2V0WCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9mZnNldFgsXG4gIG9mZnNldFkgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vZmZzZXRZLFxuICB3b3JsZFdpZHRoID0gZGVmYXVsdFByZXNldC5wYXJhbXMud29ybGRXaWR0aCxcbiAgd29ybGRIZWlnaHQgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy53b3JsZEhlaWdodCxcbiAgLy8gT3RoZXIgcHJvcHNcbiAgbWF4UGl4ZWxDb3VudCA9IDYwMTYgKiAzMzg0LFxuICAvLyBIaWdoZXIgbWF4IHJlc29sdXRpb24gZm9yIHRoaXMgc2hhZGVyXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgIC8vIE93biB1bmlmb3Jtc1xuICAgIHVfY29sb3JCYWNrOiBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmcoY29sb3JCYWNrKSxcbiAgICB1X2NvbG9yRmlsbDogZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yRmlsbCksXG4gICAgdV9jb2xvclN0cm9rZTogZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yU3Ryb2tlKSxcbiAgICB1X2RvdFNpemU6IHNpemUsXG4gICAgdV9nYXBYOiBnYXBYLFxuICAgIHVfZ2FwWTogZ2FwWSxcbiAgICB1X3N0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICB1X3NpemVSYW5nZTogc2l6ZVJhbmdlLFxuICAgIHVfb3BhY2l0eVJhbmdlOiBvcGFjaXR5UmFuZ2UsXG4gICAgdV9zaGFwZTogRG90R3JpZFNoYXBlc1tzaGFwZV0sXG4gICAgLy8gU2l6aW5nIHVuaWZvcm1zXG4gICAgdV9maXQ6IFNoYWRlckZpdE9wdGlvbnNbZml0XSxcbiAgICB1X3NjYWxlOiBzY2FsZSxcbiAgICB1X3JvdGF0aW9uOiByb3RhdGlvbixcbiAgICB1X29mZnNldFg6IG9mZnNldFgsXG4gICAgdV9vZmZzZXRZOiBvZmZzZXRZLFxuICAgIHVfb3JpZ2luWDogb3JpZ2luWCxcbiAgICB1X29yaWdpblk6IG9yaWdpblksXG4gICAgdV93b3JsZFdpZHRoOiB3b3JsZFdpZHRoLFxuICAgIHVfd29ybGRIZWlnaHQ6IHdvcmxkSGVpZ2h0XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFNoYWRlck1vdW50LCB7IC4uLnByb3BzLCBtYXhQaXhlbENvdW50LCBmcmFnbWVudFNoYWRlcjogZG90R3JpZEZyYWdtZW50U2hhZGVyLCB1bmlmb3JtcyB9KTtcbn0sIGNvbG9yUHJvcHNBcmVFcXVhbCk7XG5leHBvcnQge1xuICBEb3RHcmlkLFxuICBkZWZhdWx0UHJlc2V0LFxuICBkb3RHcmlkUHJlc2V0c1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvdC1ncmlkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/dot-grid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === \"function\" ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n  }, refs);\n}\n\n//# sourceMappingURL=use-merge-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7QUFDQSxxQkFBcUIseUNBQVk7QUFDakMsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUveW9nZXNoL0RvY3VtZW50cy9Zb2dlc2hLMzQuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMtcmVhY3QvZGlzdC91c2UtbWVyZ2UtcmVmcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICBjb25zdCBjbGVhbnVwUmVmID0gUmVhY3QudXNlUmVmKHZvaWQgMCk7XG4gIGNvbnN0IHJlZkVmZmVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChpbnN0YW5jZSkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gcmVmcy5tYXAoKHJlZikgPT4ge1xuICAgICAgaWYgKHJlZiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgICAgIGNvbnN0IHJlZkNsZWFudXAgPSByZWZDYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmQ2xlYW51cCA9PT0gXCJmdW5jdGlvblwiID8gcmVmQ2xlYW51cCA6ICgpID0+IHtcbiAgICAgICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwcy5mb3JFYWNoKChyZWZDbGVhbnVwKSA9PiByZWZDbGVhbnVwPy4oKSk7XG4gICAgfTtcbiAgfSwgcmVmcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVmcy5ldmVyeSgocmVmKSA9PiByZWYgPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoY2xlYW51cFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCgpO1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQgPSByZWZFZmZlY3QodmFsdWUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIHJlZnMpO1xufVxuZXhwb3J0IHtcbiAgdXNlTWVyZ2VSZWZzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLW1lcmdlLXJlZnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3lvZ2VzaC9Eb2N1bWVudHMvWW9nZXNoSzM0LmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuZnVuY3Rpb24gZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yU3RyaW5nKSkge1xuICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDQpIHJldHVybiBjb2xvclN0cmluZztcbiAgICBpZiAoY29sb3JTdHJpbmcubGVuZ3RoID09PSAzKSByZXR1cm4gWy4uLmNvbG9yU3RyaW5nLCAxXTtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgbGV0IHIsIGcsIGIsIGEgPSAxO1xuICBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoZXhUb1JnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJyZ2JcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBwYXJzZVJnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJoc2xcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoc2xhVG9SZ2JhKHBhcnNlSHNsYShjb2xvclN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBmb3JtYXRcIiwgY29sb3JTdHJpbmcpO1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIHJldHVybiBbY2xhbXAociwgMCwgMSksIGNsYW1wKGcsIDAsIDEpLCBjbGFtcChiLCAwLCAxKSwgY2xhbXAoYSwgMCwgMSldO1xufVxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleCkge1xuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikubWFwKChjaGFyKSA9PiBjaGFyICsgY2hhcikuam9pbihcIlwiKTtcbiAgfVxuICBpZiAoaGV4Lmxlbmd0aCA9PT0gNikge1xuICAgIGhleCA9IGhleCArIFwiZmZcIjtcbiAgfVxuICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KSAvIDI1NTtcbiAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpIC8gMjU1O1xuICBjb25zdCBhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5mdW5jdGlvbiBwYXJzZVJnYmEocmdiYSkge1xuICBjb25zdCBtYXRjaCA9IHJnYmEubWF0Y2goL15yZ2JhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFswLTkuXSspKT9cXHMqXFwpJC9pKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFswLCAwLCAwLCAxXTtcbiAgcmV0dXJuIFtcbiAgICBwYXJzZUludChtYXRjaFsxXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgcGFyc2VJbnQobWF0Y2hbMl0gPz8gXCIwXCIpIC8gMjU1LFxuICAgIHBhcnNlSW50KG1hdGNoWzNdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBtYXRjaFs0XSA9PT0gdm9pZCAwID8gMSA6IHBhcnNlRmxvYXQobWF0Y2hbNF0pXG4gIF07XG59XG5mdW5jdGlvbiBwYXJzZUhzbGEoaHNsYSkge1xuICBjb25zdCBtYXRjaCA9IGhzbGEubWF0Y2goL15oc2xhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqKD86LFxccyooWzAtOS5dKykpP1xccypcXCkkL2kpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICByZXR1cm4gW1xuICAgIHBhcnNlSW50KG1hdGNoWzFdID8/IFwiMFwiKSxcbiAgICBwYXJzZUludChtYXRjaFsyXSA/PyBcIjBcIiksXG4gICAgcGFyc2VJbnQobWF0Y2hbM10gPz8gXCIwXCIpLFxuICAgIG1hdGNoWzRdID09PSB2b2lkIDAgPyAxIDogcGFyc2VGbG9hdChtYXRjaFs0XSlcbiAgXTtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoaHNsYSkge1xuICBjb25zdCBbaCwgcywgbCwgYV0gPSBoc2xhO1xuICBjb25zdCBoRGVjaW1hbCA9IGggLyAzNjA7XG4gIGNvbnN0IHNEZWNpbWFsID0gcyAvIDEwMDtcbiAgY29uc3QgbERlY2ltYWwgPSBsIC8gMTAwO1xuICBsZXQgciwgZywgYjtcbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIgPSBsRGVjaW1hbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBodWUycmdiID0gKHAyLCBxMiwgdCkgPT4ge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwMiArIChxMiAtIHAyKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHEyO1xuICAgICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAyICsgKHEyIC0gcDIpICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHAyO1xuICAgIH07XG4gICAgY29uc3QgcSA9IGxEZWNpbWFsIDwgMC41ID8gbERlY2ltYWwgKiAoMSArIHNEZWNpbWFsKSA6IGxEZWNpbWFsICsgc0RlY2ltYWwgLSBsRGVjaW1hbCAqIHNEZWNpbWFsO1xuICAgIGNvbnN0IHAgPSAyICogbERlY2ltYWwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsICsgMSAvIDMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoRGVjaW1hbCAtIDEgLyAzKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuY29uc3QgY2xhbXAgPSAobiwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KG4sIG1pbiksIG1heCk7XG5jb25zdCBmYWxsYmFja0NvbG9yID0gWzAsIDAsIDAsIDFdO1xuZXhwb3J0IHtcbiAgY2xhbXAsXG4gIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  currentFrame = 0;\n  /** The current speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__.vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}_aspect_ratio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    const rect = this.parentElement.getBoundingClientRect();\n    this.parentWidth = rect.width;\n    this.parentHeight = rect.height;\n    this.handleResize();\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Wait 2 frames to align with when the resize observer callback is done (in case it might follow):\n  // - Frame 1: a paint after the visual viewport resize\n  // - Frame 2: a paint after the resize observer has been handled, if it was ever triggered\n  //\n  // Both resize observer and visual viewport will react to classic browser zoom changes,\n  // so we dedupe the callbacks, but pinch zoom only triggers the visual viewport handler.\n  resizeRafId = null;\n  handleVisualViewportChange = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    this.resizeRafId = requestAnimationFrame(() => {\n      this.resizeRafId = requestAnimationFrame(() => {\n        this.handleResize();\n      });\n    });\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    const pinchZoom = visualViewport?.scale ?? 1;\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const innerWidth = visualViewport ? visualViewport.scale * visualViewport.width + scrollbarWidth : window.innerWidth;\n    const classicZoom = Math.round(1e4 * window.outerWidth / innerWidth) / 1e4;\n    const realPixelRatio = this.isSafari ? devicePixelRatio : devicePixelRatio / classicZoom;\n    const targetPixelRatio = Math.max(realPixelRatio, this.minPixelRatio);\n    const targetRenderScale = targetPixelRatio * classicZoom * pinchZoom;\n    const targetPixelWidth = this.parentWidth * targetRenderScale;\n    const targetPixelHeight = this.parentHeight * targetRenderScale;\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const newRenderScale = targetRenderScale * Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(this.parentWidth * newRenderScale);\n    const newHeight = Math.round(this.parentHeight * newRenderScale);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.speed !== 0) {\n      this.currentFrame += dt * this.speed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.currentFrame * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.speed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      const textureUnit = this.textures.size - 1;\n      this.gl.useProgram(this.program);\n      this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}_aspect_ratio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      let cacheValue = value;\n      if (value instanceof HTMLImageElement) {\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      this.uniformCache[key] = cacheValue;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrame = () => {\n    return this.currentFrame;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    this.uniformLocations = {};\n    this.parentElement.paperShaderMount = void 0;\n  };\n}\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  if (precision && precision < 23) {\n    vertexShaderSource2 = vertexShaderSource2.replace(/precision\\s+(lowp|mediump)\\s+float;/g, \"precision highp float;\");\n    fragmentShaderSource = fragmentShaderSource.replace(\n      /precision\\s+(lowp|mediump)\\s+float;/g,\n      \"precision highp float;\"\n    );\n  }\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlFQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QixHQUFHLG1CQUFtQixHQUFHLG9CQUFvQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oseUVBQXlFLElBQUk7QUFDN0U7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IscURBQXFELElBQUksSUFBSSxhQUFhO0FBQzFFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsMkJBQTJCO0FBQ3JIO0FBQ0EsMENBQTBDO0FBQzFDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3lvZ2VzaC9Eb2N1bWVudHMvWW9nZXNoSzM0LmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyB2ZXJ0ZXhTaGFkZXJTb3VyY2UgfSBmcm9tIFwiLi92ZXJ0ZXgtc2hhZGVyLmpzXCI7XG5jb25zdCBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCA9IDE5MjAgKiAxMDgwICogNDtcbmNsYXNzIFNoYWRlck1vdW50IHtcbiAgcGFyZW50RWxlbWVudDtcbiAgY2FudmFzRWxlbWVudDtcbiAgZ2w7XG4gIHByb2dyYW0gPSBudWxsO1xuICB1bmlmb3JtTG9jYXRpb25zID0ge307XG4gIC8qKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHRoYXQgd2UgYXJlIHVzaW5nICovXG4gIGZyYWdtZW50U2hhZGVyO1xuICAvKiogU3RvcmVzIHRoZSBSQUYgZm9yIHRoZSByZW5kZXIgbG9vcCAqL1xuICByYWZJZCA9IG51bGw7XG4gIC8qKiBUaW1lIG9mIHRoZSBsYXN0IHJlbmRlcmVkIGZyYW1lICovXG4gIGxhc3RSZW5kZXJUaW1lID0gMDtcbiAgLyoqIFRvdGFsIHRpbWUgdGhhdCB3ZSBoYXZlIHBsYXllZCBhbnkgYW5pbWF0aW9uLCBwYXNzZWQgYXMgYSB1bmlmb3JtIHRvIHRoZSBzaGFkZXIgZm9yIHRpbWUtYmFzZWQgVkZYICovXG4gIGN1cnJlbnRGcmFtZSA9IDA7XG4gIC8qKiBUaGUgY3VycmVudCBzcGVlZCB0aGF0IHdlIHByb2dyZXNzIHRocm91Z2ggYW5pbWF0aW9uIHRpbWUgKG11bHRpcGxpZXMgYnkgZGVsdGEgdGltZSBldmVyeSB1cGRhdGUpLiBBbGxvd3MgbmVnYXRpdmVzIHRvIHBsYXkgaW4gcmV2ZXJzZS4gSWYgc2V0IHRvIDAsIHJBRiB3aWxsIHN0b3AgZW50aXJlbHkgc28gc3RhdGljIHNoYWRlcnMgaGF2ZSBubyByZWN1cnJpbmcgcGVyZm9ybWFuY2UgY29zdHMgKi9cbiAgc3BlZWQgPSAwO1xuICAvKiogVW5pZm9ybXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgZm9yIHRoZSBzcGVjaWZpYyBzaGFkZXIgYmVpbmcgbW91bnRlZCAobm90IGluY2x1ZGluZyB1bmlmb3JtcyB0aGF0IHRoaXMgTW91bnQgYWRkcywgbGlrZSB0aW1lIGFuZCByZXNvbHV0aW9uKSAqL1xuICBwcm92aWRlZFVuaWZvcm1zO1xuICAvKiogSnVzdCBhIHNhbml0eSBjaGVjayB0byBtYWtlIHN1cmUgZnJhbWVzIGRvbid0IHJ1biBhZnRlciB3ZSdyZSBkaXNwb3NlZCAqL1xuICBoYXNCZWVuRGlzcG9zZWQgPSBmYWxzZTtcbiAgLyoqIElmIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgcmVuZGVyICovXG4gIHJlc29sdXRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgLyoqIFN0b3JlIHRleHR1cmVzIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICovXG4gIHRleHR1cmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbWluUGl4ZWxSYXRpbztcbiAgbWF4UGl4ZWxDb3VudDtcbiAgaXNTYWZhcmkgPSBpc1NhZmFyaSgpO1xuICB1bmlmb3JtQ2FjaGUgPSB7fTtcbiAgY29uc3RydWN0b3IocGFyZW50RWxlbWVudCwgZnJhZ21lbnRTaGFkZXIsIHVuaWZvcm1zLCB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzLCBzcGVlZCA9IDAsIGZyYW1lID0gMCwgbWluUGl4ZWxSYXRpbyA9IDIsIG1heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCkge1xuICAgIGlmIChwYXJlbnRFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcGVyIFNoYWRlcnM6IHBhcmVudCBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnRcIik7XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInN0eWxlW2RhdGEtcGFwZXItc2hhZGVyXVwiKSkge1xuICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGRlZmF1bHRTdHlsZTtcbiAgICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcGVyLXNoYWRlclwiLCBcIlwiKTtcbiAgICAgIGRvY3VtZW50LmhlYWQucHJlcGVuZChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBjYW52YXNFbGVtZW50O1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5wcmVwZW5kKGNhbnZhc0VsZW1lbnQpO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcbiAgICB0aGlzLnByb3ZpZGVkVW5pZm9ybXMgPSB1bmlmb3JtcztcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lO1xuICAgIHRoaXMubWluUGl4ZWxSYXRpbyA9IG1pblBpeGVsUmF0aW87XG4gICAgdGhpcy5tYXhQaXhlbENvdW50ID0gbWF4UGl4ZWxDb3VudDtcbiAgICBjb25zdCBnbCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dChcIndlYmdsMlwiLCB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzKTtcbiAgICBpZiAoIWdsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXBlciBTaGFkZXJzOiBXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbiAgICB9XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMuaW5pdFByb2dyYW0oKTtcbiAgICB0aGlzLnNldHVwUG9zaXRpb25BdHRyaWJ1dGUoKTtcbiAgICB0aGlzLnNldHVwVW5pZm9ybXMoKTtcbiAgICB0aGlzLnNldFVuaWZvcm1WYWx1ZXModGhpcy5wcm92aWRlZFVuaWZvcm1zKTtcbiAgICB0aGlzLnNldHVwUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICB0aGlzLnNldFNwZWVkKHNwZWVkKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1wYXBlci1zaGFkZXJcIiwgXCJcIik7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnBhcGVyU2hhZGVyTW91bnQgPSB0aGlzO1xuICB9XG4gIGluaXRQcm9ncmFtID0gKCkgPT4ge1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKHRoaXMuZ2wsIHZlcnRleFNoYWRlclNvdXJjZSwgdGhpcy5mcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFwcm9ncmFtKSByZXR1cm47XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgfTtcbiAgc2V0dXBQb3NpdGlvbkF0dHJpYnV0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgY29uc3QgcG9zaXRpb25zID0gWy0xLCAtMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgMSwgLTEsIDEsIDFdO1xuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24pO1xuICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uLCAyLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gIH07XG4gIHNldHVwVW5pZm9ybXMgPSAoKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybUxvY2F0aW9ucyA9IHtcbiAgICAgIHVfdGltZTogdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfdGltZVwiKSxcbiAgICAgIHVfcGl4ZWxSYXRpbzogdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfcGl4ZWxSYXRpb1wiKSxcbiAgICAgIHVfcmVzb2x1dGlvbjogdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfcmVzb2x1dGlvblwiKVxuICAgIH07XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5wcm92aWRlZFVuaWZvcm1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHVuaWZvcm1Mb2NhdGlvbnNba2V5XSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwga2V5KTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSA9IGAke2tleX1fYXNwZWN0X3JhdGlvYDtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1thc3BlY3RSYXRpb1VuaWZvcm1OYW1lXSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtTG9jYXRpb25zID0gdW5pZm9ybUxvY2F0aW9ucztcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBzY2FsZSB0aGF0IHdlIHNob3VsZCByZW5kZXIgYXQuXG4gICAqIC0gVXNlZCB0byB0YXJnZXQgMnggcmVuZGVyaW5nIGV2ZW4gb24gMXggc2NyZWVucyBmb3IgYmV0dGVyIGFudGlhbGlhc2luZ1xuICAgKiAtIFByZXZlbnRzIHRoZSB2aXJ0dWFsIHJlc29sdXRpb24gZnJvbSBnb2luZyBiZXlvbmQgdGhlIG1heGltdW0gcmVzb2x1dGlvblxuICAgKiAtIEFjY291bnRzIGZvciB0aGUgcGFnZSB6b29tIGxldmVsIHNvIHdlIHJlbmRlciBpbiBwaHlzaWNhbCBkZXZpY2UgcGl4ZWxzIHJhdGhlciB0aGFuIENTUyBwaXhlbHNcbiAgICovXG4gIHJlbmRlclNjYWxlID0gMTtcbiAgcGFyZW50V2lkdGggPSAwO1xuICBwYXJlbnRIZWlnaHQgPSAwO1xuICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIHNldHVwUmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoW2VudHJ5XSkgPT4ge1xuICAgICAgaWYgKGVudHJ5Py5ib3JkZXJCb3hTaXplWzBdKSB7XG4gICAgICAgIHRoaXMucGFyZW50V2lkdGggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLmlubGluZVNpemU7XG4gICAgICAgIHRoaXMucGFyZW50SGVpZ2h0ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXS5ibG9ja1NpemU7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHZpc3VhbFZpZXdwb3J0Py5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UpO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5wYXJlbnRXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgdGhpcy5wYXJlbnRIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvLyBWaXN1YWwgdmlld3BvcnQgcmVzaXplIGhhbmRsZXIsIG1haW5seSB1c2VkIHRvIHJlYWN0IHRvIGJyb3dzZXIgem9vbSBjaGFuZ2VzLlxuICAvLyBXYWl0IDIgZnJhbWVzIHRvIGFsaWduIHdpdGggd2hlbiB0aGUgcmVzaXplIG9ic2VydmVyIGNhbGxiYWNrIGlzIGRvbmUgKGluIGNhc2UgaXQgbWlnaHQgZm9sbG93KTpcbiAgLy8gLSBGcmFtZSAxOiBhIHBhaW50IGFmdGVyIHRoZSB2aXN1YWwgdmlld3BvcnQgcmVzaXplXG4gIC8vIC0gRnJhbWUgMjogYSBwYWludCBhZnRlciB0aGUgcmVzaXplIG9ic2VydmVyIGhhcyBiZWVuIGhhbmRsZWQsIGlmIGl0IHdhcyBldmVyIHRyaWdnZXJlZFxuICAvL1xuICAvLyBCb3RoIHJlc2l6ZSBvYnNlcnZlciBhbmQgdmlzdWFsIHZpZXdwb3J0IHdpbGwgcmVhY3QgdG8gY2xhc3NpYyBicm93c2VyIHpvb20gY2hhbmdlcyxcbiAgLy8gc28gd2UgZGVkdXBlIHRoZSBjYWxsYmFja3MsIGJ1dCBwaW5jaCB6b29tIG9ubHkgdHJpZ2dlcnMgdGhlIHZpc3VhbCB2aWV3cG9ydCBoYW5kbGVyLlxuICByZXNpemVSYWZJZCA9IG51bGw7XG4gIGhhbmRsZVZpc3VhbFZpZXdwb3J0Q2hhbmdlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnJlc2l6ZVJhZklkICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlc2l6ZVJhZklkKTtcbiAgICB9XG4gICAgdGhpcy5yZXNpemVSYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZVJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKiogUmVzaXplIGhhbmRsZXIgZm9yIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgY2hhbmdlcyBzaXplIG9yIHRoZSBtYXggcGl4ZWwgY291bnQgY2hhbmdlcyBhbmQgd2Ugd2FudCB0byByZXNpemUgb3VyIGNhbnZhcyB0byBtYXRjaCAqL1xuICBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucmVzaXplUmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVzaXplUmFmSWQpO1xuICAgIH1cbiAgICBjb25zdCBwaW5jaFpvb20gPSB2aXN1YWxWaWV3cG9ydD8uc2NhbGUgPz8gMTtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGlubmVyV2lkdGggPSB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0LnNjYWxlICogdmlzdWFsVmlld3BvcnQud2lkdGggKyBzY3JvbGxiYXJXaWR0aCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNvbnN0IGNsYXNzaWNab29tID0gTWF0aC5yb3VuZCgxZTQgKiB3aW5kb3cub3V0ZXJXaWR0aCAvIGlubmVyV2lkdGgpIC8gMWU0O1xuICAgIGNvbnN0IHJlYWxQaXhlbFJhdGlvID0gdGhpcy5pc1NhZmFyaSA/IGRldmljZVBpeGVsUmF0aW8gOiBkZXZpY2VQaXhlbFJhdGlvIC8gY2xhc3NpY1pvb207XG4gICAgY29uc3QgdGFyZ2V0UGl4ZWxSYXRpbyA9IE1hdGgubWF4KHJlYWxQaXhlbFJhdGlvLCB0aGlzLm1pblBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHRhcmdldFJlbmRlclNjYWxlID0gdGFyZ2V0UGl4ZWxSYXRpbyAqIGNsYXNzaWNab29tICogcGluY2hab29tO1xuICAgIGNvbnN0IHRhcmdldFBpeGVsV2lkdGggPSB0aGlzLnBhcmVudFdpZHRoICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgY29uc3QgdGFyZ2V0UGl4ZWxIZWlnaHQgPSB0aGlzLnBhcmVudEhlaWdodCAqIHRhcmdldFJlbmRlclNjYWxlO1xuICAgIGNvbnN0IG1heFBpeGVsQ291bnRIZWFkcm9vbSA9IE1hdGguc3FydCh0aGlzLm1heFBpeGVsQ291bnQpIC8gTWF0aC5zcXJ0KHRhcmdldFBpeGVsV2lkdGggKiB0YXJnZXRQaXhlbEhlaWdodCk7XG4gICAgY29uc3QgbmV3UmVuZGVyU2NhbGUgPSB0YXJnZXRSZW5kZXJTY2FsZSAqIE1hdGgubWluKDEsIG1heFBpeGVsQ291bnRIZWFkcm9vbSk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLnJvdW5kKHRoaXMucGFyZW50V2lkdGggKiBuZXdSZW5kZXJTY2FsZSk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLnBhcmVudEhlaWdodCAqIG5ld1JlbmRlclNjYWxlKTtcbiAgICBpZiAodGhpcy5jYW52YXNFbGVtZW50LndpZHRoICE9PSBuZXdXaWR0aCB8fCB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ICE9PSBuZXdIZWlnaHQgfHwgdGhpcy5yZW5kZXJTY2FsZSAhPT0gbmV3UmVuZGVyU2NhbGUpIHtcbiAgICAgIHRoaXMucmVuZGVyU2NhbGUgPSBuZXdSZW5kZXJTY2FsZTtcbiAgICAgIHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLmdsLmNhbnZhcy53aWR0aCwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG4gIH07XG4gIHJlbmRlciA9IChjdXJyZW50VGltZSkgPT4ge1xuICAgIGlmICh0aGlzLmhhc0JlZW5EaXNwb3NlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnByb2dyYW0gPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHJlbmRlciBiZWZvcmUgcHJvZ3JhbSBvciBnbCB3YXMgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGR0ID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RSZW5kZXJUaW1lO1xuICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBpZiAodGhpcy5zcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gZHQgKiB0aGlzLnNwZWVkO1xuICAgIH1cbiAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfdGltZSwgdGhpcy5jdXJyZW50RnJhbWUgKiAxZS0zKTtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5nbC51bmlmb3JtMmYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfcmVzb2x1dGlvbiwgdGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLCB0aGlzLnJlbmRlclNjYWxlKTtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICBpZiAodGhpcy5zcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmVxdWVzdFJlbmRlciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgfVxuICAgIHRoaXMucmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpO1xuICB9O1xuICAvKiogQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSBhbiBpbWFnZSBhbmQgc2V0cyBpdCBpbnRvIGEgdW5pZm9ybSB2YWx1ZSAqL1xuICBzZXRUZXh0dXJlVW5pZm9ybSA9ICh1bmlmb3JtTmFtZSwgaW1hZ2UpID0+IHtcbiAgICBpZiAoIWltYWdlLmNvbXBsZXRlIHx8IGltYWdlLm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXBlciBTaGFkZXJzOiBpbWFnZSBmb3IgdW5pZm9ybSAke3VuaWZvcm1OYW1lfSBtdXN0IGJlIGZ1bGx5IGxvYWRlZGApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RleHR1cmUgPSB0aGlzLnRleHR1cmVzLmdldCh1bmlmb3JtTmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nVGV4dHVyZSkge1xuICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKGV4aXN0aW5nVGV4dHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5SRVBFQVQpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuUkVQRUFUKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRFcnJvcigpO1xuICAgIGlmIChlcnJvciAhPT0gdGhpcy5nbC5OT19FUlJPUiB8fCB0ZXh0dXJlID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUGFwZXIgU2hhZGVyczogV2ViR0wgZXJyb3Igd2hlbiB1cGxvYWRpbmcgdGV4dHVyZTpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVzLnNldCh1bmlmb3JtTmFtZSwgdGV4dHVyZSk7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdO1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgY29uc3QgdGV4dHVyZVVuaXQgPSB0aGlzLnRleHR1cmVzLnNpemUgLSAxO1xuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7dW5pZm9ybU5hbWV9X2FzcGVjdF9yYXRpb2A7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb0xvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW2FzcGVjdFJhdGlvVW5pZm9ybU5hbWVdO1xuICAgICAgaWYgKGFzcGVjdFJhdGlvTG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbWFnZS5uYXR1cmFsV2lkdGggLyBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihhc3BlY3RSYXRpb0xvY2F0aW9uLCBhc3BlY3RSYXRpbyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiogVXRpbGl0eTogcmVjdXJzaXZlIGVxdWFsaXR5IHRlc3QgZm9yIGFsbCB0aGUgdW5pZm9ybXMgKi9cbiAgYXJlVW5pZm9ybVZhbHVlc0VxdWFsID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhLmV2ZXJ5KCh2YWwsIGkpID0+IHRoaXMuYXJlVW5pZm9ybVZhbHVlc0VxdWFsKHZhbCwgYltpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKiBTZXRzIHRoZSBwcm92aWRlZCB1bmlmb3JtIHZhbHVlcyBpbnRvIHRoZSBXZWJHTCBwcm9ncmFtLCBjYW4gYmUgYSBwYXJ0aWFsIGxpc3Qgb2YgdW5pZm9ybXMgdGhhdCBoYXZlIGNoYW5nZWQgKi9cbiAgc2V0VW5pZm9ybVZhbHVlcyA9ICh1cGRhdGVkVW5pZm9ybXMpID0+IHtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICBPYmplY3QuZW50cmllcyh1cGRhdGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgbGV0IGNhY2hlVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgY2FjaGVWYWx1ZSA9IGAke3ZhbHVlLnNyYy5zbGljZSgwLCAyMDApfXwke3ZhbHVlLm5hdHVyYWxXaWR0aH14JHt2YWx1ZS5uYXR1cmFsSGVpZ2h0fWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcmVVbmlmb3JtVmFsdWVzRXF1YWwodGhpcy51bmlmb3JtQ2FjaGVba2V5XSwgY2FjaGVWYWx1ZSkpIHJldHVybjtcbiAgICAgIHRoaXMudW5pZm9ybUNhY2hlW2tleV0gPSBjYWNoZVZhbHVlO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNba2V5XTtcbiAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmlmb3JtIGxvY2F0aW9uIGZvciAke2tleX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlVW5pZm9ybShrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGZsYXRBcnJheSA9IG51bGw7XG4gICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZVswXSAhPT0gdm9pZCAwICYmIEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZExlbmd0aCA9IHZhbHVlWzBdLmxlbmd0aDtcbiAgICAgICAgICBpZiAodmFsdWUuZXZlcnkoKGFycikgPT4gYXJyLmxlbmd0aCA9PT0gZmlyc3RDaGlsZExlbmd0aCkpIHtcbiAgICAgICAgICAgIGZsYXRBcnJheSA9IHZhbHVlLmZsYXQoKTtcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gZmlyc3RDaGlsZExlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbGwgY2hpbGQgYXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGZvciAke2tleX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEFycmF5ID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWVMZW5ndGggPSBmbGF0QXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWVMZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0yZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0zZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm00ZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCB1bmlmb3JtIGFycmF5IGxlbmd0aDogJHt2YWx1ZUxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUgPyAxIDogMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZSBmb3IgJHtrZXl9OiAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqIEdldHMgdGhlIGN1cnJlbnQgdG90YWwgYW5pbWF0aW9uIHRpbWUgZnJvbSAwbXMgKi9cbiAgZ2V0Q3VycmVudEZyYW1lID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgfTtcbiAgLyoqIFNldCBhIGZyYW1lIHRvIGdldCBhIGRldGVybWluaXN0aWMgcmVzdWx0LCBmcmFtZXMgYXJlIGxpdGVyYWxseSBqdXN0IG1pbGxpc2Vjb25kcyBmcm9tIHplcm8gc2luY2UgdGhlIGFuaW1hdGlvbiBzdGFydGVkICovXG4gIHNldEZyYW1lID0gKG5ld0ZyYW1lKSA9PiB7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBuZXdGcmFtZTtcbiAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICB9O1xuICAvKiogU2V0IGFuIGFuaW1hdGlvbiBzcGVlZCAob3IgMCB0byBzdG9wIGFuaW1hdGlvbikgKi9cbiAgc2V0U3BlZWQgPSAobmV3U3BlZWQgPSAxKSA9PiB7XG4gICAgdGhpcy5zcGVlZCA9IG5ld1NwZWVkO1xuICAgIGlmICh0aGlzLnJhZklkID09PSBudWxsICYmIG5ld1NwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB0aGlzLnJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwgJiYgbmV3U3BlZWQgPT09IDApIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKiogU2V0IHRoZSBtYXhpbXVtIHBpeGVsIGNvdW50IGZvciB0aGUgc2hhZGVyLCB0aGlzIHdpbGwgbGltaXQgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCB3aWxsIGJlIHJlbmRlcmVkICovXG4gIHNldE1heFBpeGVsQ291bnQgPSAobmV3TWF4UGl4ZWxDb3VudCA9IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UKSA9PiB7XG4gICAgdGhpcy5tYXhQaXhlbENvdW50ID0gbmV3TWF4UGl4ZWxDb3VudDtcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvKiogU2V0IHRoZSBtaW5pbXVtIHBpeGVsIHJhdGlvIGZvciB0aGUgc2hhZGVyICovXG4gIHNldE1pblBpeGVsUmF0aW8gPSAobmV3TWluUGl4ZWxSYXRpbyA9IDIpID0+IHtcbiAgICB0aGlzLm1pblBpeGVsUmF0aW8gPSBuZXdNaW5QaXhlbFJhdGlvO1xuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gIH07XG4gIC8qKiBVcGRhdGUgdGhlIHVuaWZvcm1zIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSBvdXRzaWRlIHNoYWRlciwgY2FuIGJlIGEgcGFydGlhbCBzZXQgd2l0aCBvbmx5IHRoZSB1bmlmb3JtcyB0aGF0IGhhdmUgY2hhbmdlZCAqL1xuICBzZXRVbmlmb3JtcyA9IChuZXdVbmlmb3JtcykgPT4ge1xuICAgIHRoaXMuc2V0VW5pZm9ybVZhbHVlcyhuZXdVbmlmb3Jtcyk7XG4gICAgdGhpcy5wcm92aWRlZFVuaWZvcm1zID0geyAuLi50aGlzLnByb3ZpZGVkVW5pZm9ybXMsIC4uLm5ld1VuaWZvcm1zIH07XG4gICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICB9O1xuICAvKiogRGlzcG9zZSBvZiB0aGUgc2hhZGVyIG1vdW50LCBjbGVhbmluZyB1cCBhbGwgb2YgdGhlIFdlYkdMIHJlc291cmNlcyAqL1xuICBkaXNwb3NlID0gKCkgPT4ge1xuICAgIHRoaXMuaGFzQmVlbkRpc3Bvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgICB0aGlzLnJhZklkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2wgJiYgdGhpcy5wcm9ncmFtKSB7XG4gICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goKHRleHR1cmUpID0+IHtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRleHR1cmVzLmNsZWFyKCk7XG4gICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kUmVuZGVyYnVmZmVyKHRoaXMuZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5nZXRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gICAgdmlzdWFsVmlld3BvcnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5oYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgdGhpcy51bmlmb3JtTG9jYXRpb25zID0ge307XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnBhcGVyU2hhZGVyTW91bnQgPSB2b2lkIDA7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoZ2wsIHR5cGUsIHNvdXJjZSkge1xuICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gIGlmICghc2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCBjb21waWxpbmcgdGhlIHNoYWRlcnM6IFwiICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gc2hhZGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyU291cmNlMiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgY29uc3QgZm9ybWF0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKTtcbiAgY29uc3QgcHJlY2lzaW9uID0gZm9ybWF0ID8gZm9ybWF0LnByZWNpc2lvbiA6IG51bGw7XG4gIGlmIChwcmVjaXNpb24gJiYgcHJlY2lzaW9uIDwgMjMpIHtcbiAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2UyID0gdmVydGV4U2hhZGVyU291cmNlMi5yZXBsYWNlKC9wcmVjaXNpb25cXHMrKGxvd3B8bWVkaXVtcClcXHMrZmxvYXQ7L2csIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiKTtcbiAgICBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGZyYWdtZW50U2hhZGVyU291cmNlLnJlcGxhY2UoXG4gICAgICAvcHJlY2lzaW9uXFxzKyhsb3dwfG1lZGl1bXApXFxzK2Zsb2F0Oy9nLFxuICAgICAgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XCJcbiAgICApO1xuICB9XG4gIGNvbnN0IHZlcnRleFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlMik7XG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgaWYgKCFwcm9ncmFtKSByZXR1cm4gbnVsbDtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbTogXCIgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdsLmRldGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgcmV0dXJuIHByb2dyYW07XG59XG5jb25zdCBkZWZhdWx0U3R5bGUgPSBgQGxheWVyIHBhcGVyLXNoYWRlcnMge1xuICA6d2hlcmUoW2RhdGEtcGFwZXItc2hhZGVyXSkge1xuICAgIGlzb2xhdGlvbjogaXNvbGF0ZTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmIGNhbnZhcyB7XG4gICAgICBjb250YWluOiBzdHJpY3Q7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGluc2V0OiAwO1xuICAgICAgei1pbmRleDogLTE7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgfVxuICB9XG59YDtcbmZ1bmN0aW9uIGlzUGFwZXJTaGFkZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwicGFwZXJTaGFkZXJNb3VudFwiIGluIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB1YS5pbmNsdWRlcyhcInNhZmFyaVwiKSAmJiAhdWEuaW5jbHVkZXMoXCJjaHJvbWVcIikgJiYgIXVhLmluY2x1ZGVzKFwiYW5kcm9pZFwiKTtcbn1cbmV4cG9ydCB7XG4gIFNoYWRlck1vdW50LFxuICBpc1BhcGVyU2hhZGVyRWxlbWVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1tb3VudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3lvZ2VzaC9Eb2N1bWVudHMvWW9nZXNoSzM0LmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3Qgc2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb24gPSBgXG5pbiB2ZWMyIHZfb2JqZWN0VVY7XG5pbiB2ZWMyIHZfcmVzcG9uc2l2ZVVWO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG5pbiB2ZWMyIHZfcGF0dGVyblVWO2A7XG5jb25zdCBzaXppbmdEZWJ1Z1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdEJveFNpemU7XG5pbiB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hTaXplO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5pbiB2ZWMyIHZfcGF0dGVybkJveFNpemU7XG5pbiB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtgO1xuY29uc3Qgc2l6aW5nVW5pZm9ybXNEZWNsYXJhdGlvbiA9IGBcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5YO1xudW5pZm9ybSBmbG9hdCB1X29yaWdpblk7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRXaWR0aDtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZEhlaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9maXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbnVuaWZvcm0gZmxvYXQgdV9yb3RhdGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRYO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFk7YDtcbmNvbnN0IHNpemluZ1VWID0gYFxuXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICNpZmRlZiBVU0VfUElYRUxJWkFUSU9OXG4gICAgZmxvYXQgcHhTaXplID0gdV9weFNpemUgKiB1X3BpeGVsUmF0aW87XG4gICAgdmVjMiBweFNpemVVdiA9IGdsX0ZyYWdDb29yZC54eTtcbiAgICBweFNpemVVdiAtPSAuNSAqIHVfcmVzb2x1dGlvbjtcbiAgICBweFNpemVVdiAvPSBweFNpemU7XG4gICAgdXYgPSBmbG9vcihweFNpemVVdikgKiBweFNpemUgLyB1X3Jlc29sdXRpb24ueHk7ICAgIFxuICAgIHV2ICs9IC41O1xuICAjZW5kaWZcbiAgdXYgLT0gLjU7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBzaXppbmcgcGFyYW1zIHNoYXJlZCBiZXR3ZWVuIG9iamVjdHMgYW5kIHBhdHRlcm5zXG4gIFxuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgdmVjMiBtYXhCb3hTaXplID0gdmVjMihtYXgodV9yZXNvbHV0aW9uLngsIGdpdmVuQm94U2l6ZS54KSwgbWF4KHVfcmVzb2x1dGlvbi55LCBnaXZlbkJveFNpemUueSkpO1xuICBmbG9hdCByID0gdV9yb3RhdGlvbiAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYgLyAxODAuO1xuICBtYXQyIGdyYXBoaWNSb3RhdGlvbiA9IG1hdDIoY29zKHIpLCBzaW4ociksIC1zaW4ociksIGNvcyhyKSk7XG4gIHZlYzIgZ3JhcGhpY09mZnNldCA9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcblxuICBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIG9iamVjdHMgKGdyYXBoaWNzIHdpdGggZml4ZWQgcmF0aW8pXG5cbiAgI2lmZGVmIFVTRV9PQkpFQ1RfU0laSU5HXG4gICAgZmxvYXQgZml4ZWRSYXRpbyA9IDEuO1xuICAgIHZlYzIgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICAgICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICAgICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICAgKTtcbiAgICB2ZWMyIG9iamVjdEJveFNpemUgPSB2ZWMyKDAuKTtcbiAgICAvLyBmaXQgPSBub25lXG4gICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1pbihmaXhlZFJhdGlvQm94R2l2ZW5TaXplLnggLyBmaXhlZFJhdGlvLCBmaXhlZFJhdGlvQm94R2l2ZW5TaXplLnkpO1xuICAgIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBmaXQgPSBjb250YWluXG4gICAgICBvYmplY3RCb3hTaXplLnggPSBmaXhlZFJhdGlvICogbWluKG1heEJveFNpemUueCAvIGZpeGVkUmF0aW8sIG1heEJveFNpemUueSk7XG4gICAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAgLy8gZml0ID0gY292ZXJcbiAgICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtYXgobWF4Qm94U2l6ZS54IC8gZml4ZWRSYXRpbywgbWF4Qm94U2l6ZS55KTtcbiAgICB9XG4gICAgb2JqZWN0Qm94U2l6ZS55ID0gb2JqZWN0Qm94U2l6ZS54IC8gZml4ZWRSYXRpbztcbiAgICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBvYmplY3RCb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgb2JqZWN0SGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgb2JqZWN0SGVscGVyQm94IC09IC41O1xuICAgICAgb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgICBvYmplY3RIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7ICBcbiAgICAjZW5kaWZcbiAgXG4gICAgdmVjMiBvYmplY3RVViA9IHV2O1xuICAgIG9iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gICAgb2JqZWN0VVYgKz0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuICAgIG9iamVjdFVWIC89IHVfc2NhbGU7XG4gICAgb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiBvYmplY3RVVjtcbiAgI2VuZGlmXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIHBhdHRlcm5zIChncmFwaGljcyByZXNwZWN0aW5nIHVfd29ybGRXaWR0aCAvIHVfd29ybGRIZWlnaHQgcmF0aW8pXG4gIFxuICAjaWZkZWYgVVNFX1BBVFRFUk5fU0laSU5HXG4gICAgZmxvYXQgcGF0dGVybkJveFJhdGlvID0gZ2l2ZW5Cb3hTaXplLnggLyBnaXZlbkJveFNpemUueTtcbiAgICB2ZWMyIHBhdHRlcm5Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBwYXR0ZXJuQm94U2l6ZSA9IHZlYzIoMC4pO1xuICAgIC8vIGZpdCA9IG5vbmVcbiAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWluKHBhdHRlcm5Cb3hHaXZlblNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZS55KTtcbiAgICBmbG9hdCBwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoID0gcGF0dGVybkJveFNpemUueDtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgIC8vIGZpdCA9IGNvbnRhaW5cbiAgICAgIHBhdHRlcm5Cb3hTaXplLnggPSBwYXR0ZXJuQm94UmF0aW8gKiBtaW4obWF4Qm94U2l6ZS54IC8gcGF0dGVybkJveFJhdGlvLCBtYXhCb3hTaXplLnkpO1xuICAgIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgIC8vIGZpdCA9IGNvdmVyXG4gICAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWF4KG1heEJveFNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgbWF4Qm94U2l6ZS55KTtcbiAgICB9XG4gICAgcGF0dGVybkJveFNpemUueSA9IHBhdHRlcm5Cb3hTaXplLnggLyBwYXR0ZXJuQm94UmF0aW87XG4gICAgdmVjMiBwYXR0ZXJuV29ybGRTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHBhdHRlcm5Cb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlMgIFxuICAgICAgdmVjMiBwYXR0ZXJuSGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgcGF0dGVybkhlbHBlckJveCAtPSAuNTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggKj0gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChwYXR0ZXJuV29ybGRTY2FsZSAtIDEuKTsgIFxuICAgICNlbmRpZlxuICBcbiAgICB2ZWMyIHBhdHRlcm5VViA9IHV2O1xuICAgIHBhdHRlcm5VViArPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSkgLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgKz0gYm94T3JpZ2luO1xuICAgIHBhdHRlcm5VViAtPSBib3hPcmlnaW4gLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgKj0gdV9yZXNvbHV0aW9uLnh5O1xuICAgIHBhdHRlcm5VViAvPSB1X3BpeGVsUmF0aW87XG4gICAgaWYgKHVfZml0ID4gMC4pIHtcbiAgICAgIHBhdHRlcm5VViAqPSAocGF0dGVybldvcmxkTm9GaXRCb3hXaWR0aCAvIHBhdHRlcm5Cb3hTaXplLngpO1xuICAgIH1cbiAgICBwYXR0ZXJuVVYgLz0gdV9zY2FsZTtcbiAgICBwYXR0ZXJuVVYgPSBncmFwaGljUm90YXRpb24gKiBwYXR0ZXJuVVY7XG4gICAgcGF0dGVyblVWICs9IGJveE9yaWdpbiAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViAtPSBib3hPcmlnaW47XG4gICAgcGF0dGVyblVWICs9IC41O1xuICAjZW5kaWZcbmA7XG5jb25zdCBkcmF3U2l6aW5nSGVscGVycyA9IGBcbiAgdmVjMiB3b3JsZEJveERpc3QgPSBhYnMoaGVscGVyQm94KTtcbiAgZmxvYXQgYm94U3Ryb2tlID0gKHN0ZXAobWF4KHdvcmxkQm94RGlzdC54LCB3b3JsZEJveERpc3QueSksIC41KSAtIHN0ZXAobWF4KHdvcmxkQm94RGlzdC54LCB3b3JsZEJveERpc3QueSksIC40OTUpKTtcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygxLiwgMC4sIDAuKSwgYm94U3Ryb2tlKTtcbiAgb3BhY2l0eSArPSBib3hTdHJva2U7XG5cbiAgdmVjMiBib3hPcmlnaW5Db3B5ID0gdmVjMiguNSAtIHVfb3JpZ2luWCwgdV9vcmlnaW5ZIC0gLjUpO1xuICB2ZWMyIGJveE9yaWdpbkRpc3QgPSBoZWxwZXJCb3ggKyBib3hPcmlnaW5Db3B5O1xuICBib3hPcmlnaW5EaXN0LnggKj0gKGJveFNpemUueCAvIGJveFNpemUueSk7XG4gIGZsb2F0IGJveE9yaWdpblBvaW50ID0gMS4gLSBzbW9vdGhzdGVwKDAuLCAuMDUsIGxlbmd0aChib3hPcmlnaW5EaXN0KSk7XG4gIFxuICB2ZWMyIGdyYXBoaWNPcmlnaW5Qb2ludERpc3QgPSBoZWxwZXJCb3ggKyB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG4gIGdyYXBoaWNPcmlnaW5Qb2ludERpc3QueCAqPSAoYm94U2l6ZS54IC8gYm94U2l6ZS55KTtcbiAgZmxvYXQgZ3JhcGhpY09yaWdpblBvaW50ID0gMS4gLSBzbW9vdGhzdGVwKDAuLCAuMDUsIGxlbmd0aChncmFwaGljT3JpZ2luUG9pbnREaXN0KSk7XG4gIFxuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDAuLCAxLiwgMC4pLCBib3hPcmlnaW5Qb2ludCk7XG4gIG9wYWNpdHkgKz0gYm94T3JpZ2luUG9pbnQ7XG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMC4sIDAuLCAxLiksIGdyYXBoaWNPcmlnaW5Qb2ludCk7XG4gIG9wYWNpdHkgKz0gZ3JhcGhpY09yaWdpblBvaW50O1xuYDtcbmNvbnN0IGRlZmF1bHRPYmplY3RTaXppbmcgPSB7XG4gIGZpdDogXCJjb250YWluXCIsXG4gIHNjYWxlOiAxLFxuICByb3RhdGlvbjogMCxcbiAgb2Zmc2V0WDogMCxcbiAgb2Zmc2V0WTogMCxcbiAgb3JpZ2luWDogMC41LFxuICBvcmlnaW5ZOiAwLjUsXG4gIHdvcmxkV2lkdGg6IDAsXG4gIHdvcmxkSGVpZ2h0OiAwXG59O1xuY29uc3QgZGVmYXVsdFBhdHRlcm5TaXppbmcgPSB7XG4gIGZpdDogXCJub25lXCIsXG4gIHNjYWxlOiAxLFxuICByb3RhdGlvbjogMCxcbiAgb2Zmc2V0WDogMCxcbiAgb2Zmc2V0WTogMCxcbiAgb3JpZ2luWDogMC41LFxuICBvcmlnaW5ZOiAwLjUsXG4gIHdvcmxkV2lkdGg6IDAsXG4gIHdvcmxkSGVpZ2h0OiAwXG59O1xuY29uc3QgU2hhZGVyRml0T3B0aW9ucyA9IHtcbiAgbm9uZTogMCxcbiAgY29udGFpbjogMSxcbiAgY292ZXI6IDJcbn07XG5leHBvcnQge1xuICBTaGFkZXJGaXRPcHRpb25zLFxuICBkZWZhdWx0T2JqZWN0U2l6aW5nLFxuICBkZWZhdWx0UGF0dGVyblNpemluZyxcbiAgZHJhd1NpemluZ0hlbHBlcnMsXG4gIHNpemluZ0RlYnVnVmFyaWFibGVzRGVjbGFyYXRpb24sXG4gIHNpemluZ1VWLFxuICBzaXppbmdVbmlmb3Jtc0RlY2xhcmF0aW9uLFxuICBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1zaXppbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declareGrainShape: () => (/* binding */ declareGrainShape),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   declareRandom: () => (/* binding */ declareRandom),\n/* harmony export */   declareRotate: () => (/* binding */ declareRotate),\n/* harmony export */   declareSimplexNoise: () => (/* binding */ declareSimplexNoise),\n/* harmony export */   declareValueNoise: () => (/* binding */ declareValueNoise)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst declareRotate = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst declareRandom = `\nfloat random(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n`;\nconst declareValueNoise = `\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst declareSimplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\nconst declareGrainShape = `\nvec2 grainRandom(vec2 p) {\n  float angle = fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n  angle *= 6.2831853;\n  return vec2(cos(angle), sin(angle));\n}\n\nfloat grainNoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  float n00 = dot(grainRandom(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n  float n10 = dot(grainRandom(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n  float n01 = dot(grainRandom(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n  float n11 = dot(grainRandom(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n\n  float nx0 = mix(n00, n10, u.x);\n  float nx1 = mix(n01, n11, u.x);\n  return mix(nx0, nx1, u.y);\n}\n\nfloat grainShape(vec2 uv, vec2 seedOffset) {\n  float total = 0.0;\n  float amp = 0.5;\n  float freq = .6;\n\n  for (int i = 0; i < 4; i++) {\n    total += amp * grainNoise(uv * freq + seedOffset);\n    freq *= 2.;\n    amp *= .5;\n  }\n\n  total = .5 + .5 * total;\n  return 10. * u_scale * length(vec2(dFdx(total), dFdy(total)));\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3lvZ2VzaC9Eb2N1bWVudHMvWW9nZXNoSzM0LmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCBkZWNsYXJlUEkgPSBgXG4jZGVmaW5lIFRXT19QSSA2LjI4MzE4NTMwNzE4XG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDZcbmA7XG5jb25zdCBkZWNsYXJlUm90YXRlID0gYFxudmVjMiByb3RhdGUodmVjMiB1diwgZmxvYXQgdGgpIHtcbiAgcmV0dXJuIG1hdDIoY29zKHRoKSwgc2luKHRoKSwgLXNpbih0aCksIGNvcyh0aCkpICogdXY7XG59XG5gO1xuY29uc3QgZGVjbGFyZVJhbmRvbSA9IGBcbmZsb2F0IHJhbmRvbSh2ZWMyIHN0KSB7XG4gIHJldHVybiBmcmFjdChzaW4oZG90KHN0Lnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpO1xufVxuYDtcbmNvbnN0IGRlY2xhcmVWYWx1ZU5vaXNlID0gYFxuZmxvYXQgdmFsdWVOb2lzZSh2ZWMyIHN0KSB7XG4gIHZlYzIgaSA9IGZsb29yKHN0KTtcbiAgdmVjMiBmID0gZnJhY3Qoc3QpO1xuICBmbG9hdCBhID0gcmFuZG9tKGkpO1xuICBmbG9hdCBiID0gcmFuZG9tKGkgKyB2ZWMyKDEuMCwgMC4wKSk7XG4gIGZsb2F0IGMgPSByYW5kb20oaSArIHZlYzIoMC4wLCAxLjApKTtcbiAgZmxvYXQgZCA9IHJhbmRvbShpICsgdmVjMigxLjAsIDEuMCkpO1xuICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTtcbiAgZmxvYXQgeDEgPSBtaXgoYSwgYiwgdS54KTtcbiAgZmxvYXQgeDIgPSBtaXgoYywgZCwgdS54KTtcbiAgcmV0dXJuIG1peCh4MSwgeDIsIHUueSk7XG59XG5gO1xuY29uc3QgY29sb3JCYW5kaW5nRml4ID0gYFxuICBjb2xvciArPSAxLiAvIDI1Ni4gKiAoZnJhY3Qoc2luKGRvdCguMDE0ICogZ2xfRnJhZ0Nvb3JkLnh5LCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpIC0gLjUpO1xuYDtcbmNvbnN0IGRlY2xhcmVTaW1wbGV4Tm9pc2UgPSBgXG52ZWMzIHBlcm11dGUodmVjMyB4KSB7IHJldHVybiBtb2QoKCh4ICogMzQuMCkgKyAxLjApICogeCwgMjg5LjApOyB9XG5mbG9hdCBzbm9pc2UodmVjMiB2KSB7XG4gIGNvbnN0IHZlYzQgQyA9IHZlYzQoMC4yMTEzMjQ4NjU0MDUxODcsIDAuMzY2MDI1NDAzNzg0NDM5LFxuICAgIC0wLjU3NzM1MDI2OTE4OTYyNiwgMC4wMjQzOTAyNDM5MDI0MzkpO1xuICB2ZWMyIGkgPSBmbG9vcih2ICsgZG90KHYsIEMueXkpKTtcbiAgdmVjMiB4MCA9IHYgLSBpICsgZG90KGksIEMueHgpO1xuICB2ZWMyIGkxO1xuICBpMSA9ICh4MC54ID4geDAueSkgPyB2ZWMyKDEuMCwgMC4wKSA6IHZlYzIoMC4wLCAxLjApO1xuICB2ZWM0IHgxMiA9IHgwLnh5eHkgKyBDLnh4eno7XG4gIHgxMi54eSAtPSBpMTtcbiAgaSA9IG1vZChpLCAyODkuMCk7XG4gIHZlYzMgcCA9IHBlcm11dGUocGVybXV0ZShpLnkgKyB2ZWMzKDAuMCwgaTEueSwgMS4wKSlcbiAgICArIGkueCArIHZlYzMoMC4wLCBpMS54LCAxLjApKTtcbiAgdmVjMyBtID0gbWF4KDAuNSAtIHZlYzMoZG90KHgwLCB4MCksIGRvdCh4MTIueHksIHgxMi54eSksXG4gICAgICBkb3QoeDEyLnp3LCB4MTIuencpKSwgMC4wKTtcbiAgbSA9IG0gKiBtO1xuICBtID0gbSAqIG07XG4gIHZlYzMgeCA9IDIuMCAqIGZyYWN0KHAgKiBDLnd3dykgLSAxLjA7XG4gIHZlYzMgaCA9IGFicyh4KSAtIDAuNTtcbiAgdmVjMyBveCA9IGZsb29yKHggKyAwLjUpO1xuICB2ZWMzIGEwID0geCAtIG94O1xuICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKGEwICogYTAgKyBoICogaCk7XG4gIHZlYzMgZztcbiAgZy54ID0gYTAueCAqIHgwLnggKyBoLnggKiB4MC55O1xuICBnLnl6ID0gYTAueXogKiB4MTIueHogKyBoLnl6ICogeDEyLnl3O1xuICByZXR1cm4gMTMwLjAgKiBkb3QobSwgZyk7XG59XG5gO1xuY29uc3QgZGVjbGFyZUdyYWluU2hhcGUgPSBgXG52ZWMyIGdyYWluUmFuZG9tKHZlYzIgcCkge1xuICBmbG9hdCBhbmdsZSA9IGZyYWN0KHNpbihkb3QocCwgdmVjMigxMjcuMSwgMzExLjcpKSkgKiA0Mzc1OC41NDUzKTtcbiAgYW5nbGUgKj0gNi4yODMxODUzO1xuICByZXR1cm4gdmVjMihjb3MoYW5nbGUpLCBzaW4oYW5nbGUpKTtcbn1cblxuZmxvYXQgZ3JhaW5Ob2lzZSh2ZWMyIHApIHtcbiAgdmVjMiBpID0gZmxvb3IocCk7XG4gIHZlYzIgZiA9IGZyYWN0KHApO1xuICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTtcblxuICBmbG9hdCBuMDAgPSBkb3QoZ3JhaW5SYW5kb20oaSArIHZlYzIoMC4wLCAwLjApKSwgZiAtIHZlYzIoMC4wLCAwLjApKTtcbiAgZmxvYXQgbjEwID0gZG90KGdyYWluUmFuZG9tKGkgKyB2ZWMyKDEuMCwgMC4wKSksIGYgLSB2ZWMyKDEuMCwgMC4wKSk7XG4gIGZsb2F0IG4wMSA9IGRvdChncmFpblJhbmRvbShpICsgdmVjMigwLjAsIDEuMCkpLCBmIC0gdmVjMigwLjAsIDEuMCkpO1xuICBmbG9hdCBuMTEgPSBkb3QoZ3JhaW5SYW5kb20oaSArIHZlYzIoMS4wLCAxLjApKSwgZiAtIHZlYzIoMS4wLCAxLjApKTtcblxuICBmbG9hdCBueDAgPSBtaXgobjAwLCBuMTAsIHUueCk7XG4gIGZsb2F0IG54MSA9IG1peChuMDEsIG4xMSwgdS54KTtcbiAgcmV0dXJuIG1peChueDAsIG54MSwgdS55KTtcbn1cblxuZmxvYXQgZ3JhaW5TaGFwZSh2ZWMyIHV2LCB2ZWMyIHNlZWRPZmZzZXQpIHtcbiAgZmxvYXQgdG90YWwgPSAwLjA7XG4gIGZsb2F0IGFtcCA9IDAuNTtcbiAgZmxvYXQgZnJlcSA9IC42O1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdG90YWwgKz0gYW1wICogZ3JhaW5Ob2lzZSh1diAqIGZyZXEgKyBzZWVkT2Zmc2V0KTtcbiAgICBmcmVxICo9IDIuO1xuICAgIGFtcCAqPSAuNTtcbiAgfVxuXG4gIHRvdGFsID0gLjUgKyAuNSAqIHRvdGFsO1xuICByZXR1cm4gMTAuICogdV9zY2FsZSAqIGxlbmd0aCh2ZWMyKGRGZHgodG90YWwpLCBkRmR5KHRvdGFsKSkpO1xufVxuYDtcbmV4cG9ydCB7XG4gIGNvbG9yQmFuZGluZ0ZpeCxcbiAgZGVjbGFyZUdyYWluU2hhcGUsXG4gIGRlY2xhcmVQSSxcbiAgZGVjbGFyZVJhbmRvbSxcbiAgZGVjbGFyZVJvdGF0ZSxcbiAgZGVjbGFyZVNpbXBsZXhOb2lzZSxcbiAgZGVjbGFyZVZhbHVlTm9pc2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/dot-grid.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/dot-grid.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DotGridShapes: () => (/* binding */ DotGridShapes),\n/* harmony export */   dotGridFragmentShader: () => (/* binding */ dotGridFragmentShader)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst dotGridFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform vec4 u_colorBack;\nuniform vec4 u_colorFill;\nuniform vec4 u_colorStroke;\nuniform float u_dotSize;\nuniform float u_gapX;\nuniform float u_gapY;\nuniform float u_strokeWidth;\nuniform float u_sizeRange;\nuniform float u_opacityRange;\nuniform float u_shape;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declareSimplexNoise}\n\nfloat polygon(vec2 p, float N, float rot) {\n  float a = atan(p.x, p.y) + rot;\n  float r = TWO_PI / float(N);\n\n  return cos(floor(.5 + a / r) * r - a) * length(p);\n}\n\nvoid main() {\n\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  vec2 shape_uv = 100. * v_patternUV;\n\n  vec2 grid = fract(shape_uv / vec2(u_gapX, u_gapY)) + 1e-4;\n  vec2 grid_idx = floor(shape_uv / vec2(u_gapX, u_gapY));\n  float sizeRandomizer = .5 + .8 * snoise(2. * vec2(grid_idx.x * 100., grid_idx.y));\n  float opacity_randomizer = .5 + .7 * snoise(2. * vec2(grid_idx.y, grid_idx.x));\n\n  vec2 center = vec2(0.5) - 1e-3;\n  vec2 p = (grid - center) * vec2(u_gapX, u_gapY);\n\n  float baseSize = u_dotSize * (1. - sizeRandomizer * u_sizeRange);\n  float strokeWidth = u_strokeWidth * (1. - sizeRandomizer * u_sizeRange);\n\n  float dist;\n  if (u_shape < 0.5) {\n    // Circle\n    dist = length(p);\n  } else if (u_shape < 1.5) {\n    // Diamond\n    strokeWidth *= 1.5;\n    dist = polygon(1.5 * p, 4., .25 * PI);\n  } else if (u_shape < 2.5) {\n    // Square\n    dist = polygon(1.03 * p, 4., 1e-3);\n  } else {\n    // Triangle\n    strokeWidth *= 1.5;\n    p = p * 2. - 1.;\n    p *= .9;\n    p.y = 1. - p.y;\n    p.y -= .75 * baseSize;\n    dist = polygon(p, 3., 1e-3);\n  }\n\n  float edgeWidth = fwidth(dist);\n  float shapeOuter = smoothstep(baseSize + edgeWidth, baseSize - edgeWidth, dist - strokeWidth);\n  float shapeInner = smoothstep(baseSize + edgeWidth, baseSize - edgeWidth, dist);\n  float stroke = shapeOuter - shapeInner;\n\n  float dotOpacity = max(0., 1. - opacity_randomizer * u_opacityRange);\n  stroke *= dotOpacity;\n  shapeInner *= dotOpacity;\n\n  stroke *= u_colorStroke.a;\n  shapeInner *= u_colorFill.a;\n\n  vec3 color = vec3(0.);\n  color += stroke * u_colorStroke.rgb;\n  color += shapeInner * u_colorFill.rgb;\n  color += (1. - shapeInner - stroke) * u_colorBack.rgb * u_colorBack.a;\n\n  float opacity = 0.;\n  opacity += stroke;\n  opacity += shapeInner;\n  opacity += (1. - opacity) * u_colorBack.a;\n\n  fragColor = vec4(color, opacity);\n}\n`;\nconst DotGridShapes = {\n  circle: 0,\n  diamond: 1,\n  square: 2,\n  triangle: 3\n};\n\n//# sourceMappingURL=dot-grid.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9kb3QtZ3JpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWlFO0FBQ0c7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLHlFQUEwQjs7QUFFNUI7O0FBRUEsRUFBRSx1REFBUztBQUNYLEVBQUUsaUVBQW1COztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUveW9nZXNoL0RvY3VtZW50cy9Zb2dlc2hLMzQuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXJzL2RvdC1ncmlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbiB9IGZyb20gXCIuLi9zaGFkZXItc2l6aW5nLmpzXCI7XG5pbXBvcnQgeyBkZWNsYXJlUEksIGRlY2xhcmVTaW1wbGV4Tm9pc2UgfSBmcm9tIFwiLi4vc2hhZGVyLXV0aWxzLmpzXCI7XG5jb25zdCBkb3RHcmlkRnJhZ21lbnRTaGFkZXIgPSBgI3ZlcnNpb24gMzAwIGVzXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxudW5pZm9ybSB2ZWM0IHVfY29sb3JCYWNrO1xudW5pZm9ybSB2ZWM0IHVfY29sb3JGaWxsO1xudW5pZm9ybSB2ZWM0IHVfY29sb3JTdHJva2U7XG51bmlmb3JtIGZsb2F0IHVfZG90U2l6ZTtcbnVuaWZvcm0gZmxvYXQgdV9nYXBYO1xudW5pZm9ybSBmbG9hdCB1X2dhcFk7XG51bmlmb3JtIGZsb2F0IHVfc3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhbmdlO1xudW5pZm9ybSBmbG9hdCB1X29wYWNpdHlSYW5nZTtcbnVuaWZvcm0gZmxvYXQgdV9zaGFwZTtcblxuJHtzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbn1cblxub3V0IHZlYzQgZnJhZ0NvbG9yO1xuXG4ke2RlY2xhcmVQSX1cbiR7ZGVjbGFyZVNpbXBsZXhOb2lzZX1cblxuZmxvYXQgcG9seWdvbih2ZWMyIHAsIGZsb2F0IE4sIGZsb2F0IHJvdCkge1xuICBmbG9hdCBhID0gYXRhbihwLngsIHAueSkgKyByb3Q7XG4gIGZsb2F0IHIgPSBUV09fUEkgLyBmbG9hdChOKTtcblxuICByZXR1cm4gY29zKGZsb29yKC41ICsgYSAvIHIpICogciAtIGEpICogbGVuZ3RoKHApO1xufVxuXG52b2lkIG1haW4oKSB7XG5cbiAgLy8geDEwMCBpcyBhIGRlZmF1bHQgbXVsdGlwbGllciBiZXR3ZWVuIHZlcnRleCBhbmQgZnJhZ21hbnQgc2hhZGVyc1xuICAvLyB3ZSB1c2UgaXQgdG8gYXZvaWQgVVYgcHJlc2lzaW9uIGlzc3Vlc1xuICB2ZWMyIHNoYXBlX3V2ID0gMTAwLiAqIHZfcGF0dGVyblVWO1xuXG4gIHZlYzIgZ3JpZCA9IGZyYWN0KHNoYXBlX3V2IC8gdmVjMih1X2dhcFgsIHVfZ2FwWSkpICsgMWUtNDtcbiAgdmVjMiBncmlkX2lkeCA9IGZsb29yKHNoYXBlX3V2IC8gdmVjMih1X2dhcFgsIHVfZ2FwWSkpO1xuICBmbG9hdCBzaXplUmFuZG9taXplciA9IC41ICsgLjggKiBzbm9pc2UoMi4gKiB2ZWMyKGdyaWRfaWR4LnggKiAxMDAuLCBncmlkX2lkeC55KSk7XG4gIGZsb2F0IG9wYWNpdHlfcmFuZG9taXplciA9IC41ICsgLjcgKiBzbm9pc2UoMi4gKiB2ZWMyKGdyaWRfaWR4LnksIGdyaWRfaWR4LngpKTtcblxuICB2ZWMyIGNlbnRlciA9IHZlYzIoMC41KSAtIDFlLTM7XG4gIHZlYzIgcCA9IChncmlkIC0gY2VudGVyKSAqIHZlYzIodV9nYXBYLCB1X2dhcFkpO1xuXG4gIGZsb2F0IGJhc2VTaXplID0gdV9kb3RTaXplICogKDEuIC0gc2l6ZVJhbmRvbWl6ZXIgKiB1X3NpemVSYW5nZSk7XG4gIGZsb2F0IHN0cm9rZVdpZHRoID0gdV9zdHJva2VXaWR0aCAqICgxLiAtIHNpemVSYW5kb21pemVyICogdV9zaXplUmFuZ2UpO1xuXG4gIGZsb2F0IGRpc3Q7XG4gIGlmICh1X3NoYXBlIDwgMC41KSB7XG4gICAgLy8gQ2lyY2xlXG4gICAgZGlzdCA9IGxlbmd0aChwKTtcbiAgfSBlbHNlIGlmICh1X3NoYXBlIDwgMS41KSB7XG4gICAgLy8gRGlhbW9uZFxuICAgIHN0cm9rZVdpZHRoICo9IDEuNTtcbiAgICBkaXN0ID0gcG9seWdvbigxLjUgKiBwLCA0LiwgLjI1ICogUEkpO1xuICB9IGVsc2UgaWYgKHVfc2hhcGUgPCAyLjUpIHtcbiAgICAvLyBTcXVhcmVcbiAgICBkaXN0ID0gcG9seWdvbigxLjAzICogcCwgNC4sIDFlLTMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRyaWFuZ2xlXG4gICAgc3Ryb2tlV2lkdGggKj0gMS41O1xuICAgIHAgPSBwICogMi4gLSAxLjtcbiAgICBwICo9IC45O1xuICAgIHAueSA9IDEuIC0gcC55O1xuICAgIHAueSAtPSAuNzUgKiBiYXNlU2l6ZTtcbiAgICBkaXN0ID0gcG9seWdvbihwLCAzLiwgMWUtMyk7XG4gIH1cblxuICBmbG9hdCBlZGdlV2lkdGggPSBmd2lkdGgoZGlzdCk7XG4gIGZsb2F0IHNoYXBlT3V0ZXIgPSBzbW9vdGhzdGVwKGJhc2VTaXplICsgZWRnZVdpZHRoLCBiYXNlU2l6ZSAtIGVkZ2VXaWR0aCwgZGlzdCAtIHN0cm9rZVdpZHRoKTtcbiAgZmxvYXQgc2hhcGVJbm5lciA9IHNtb290aHN0ZXAoYmFzZVNpemUgKyBlZGdlV2lkdGgsIGJhc2VTaXplIC0gZWRnZVdpZHRoLCBkaXN0KTtcbiAgZmxvYXQgc3Ryb2tlID0gc2hhcGVPdXRlciAtIHNoYXBlSW5uZXI7XG5cbiAgZmxvYXQgZG90T3BhY2l0eSA9IG1heCgwLiwgMS4gLSBvcGFjaXR5X3JhbmRvbWl6ZXIgKiB1X29wYWNpdHlSYW5nZSk7XG4gIHN0cm9rZSAqPSBkb3RPcGFjaXR5O1xuICBzaGFwZUlubmVyICo9IGRvdE9wYWNpdHk7XG5cbiAgc3Ryb2tlICo9IHVfY29sb3JTdHJva2UuYTtcbiAgc2hhcGVJbm5lciAqPSB1X2NvbG9yRmlsbC5hO1xuXG4gIHZlYzMgY29sb3IgPSB2ZWMzKDAuKTtcbiAgY29sb3IgKz0gc3Ryb2tlICogdV9jb2xvclN0cm9rZS5yZ2I7XG4gIGNvbG9yICs9IHNoYXBlSW5uZXIgKiB1X2NvbG9yRmlsbC5yZ2I7XG4gIGNvbG9yICs9ICgxLiAtIHNoYXBlSW5uZXIgLSBzdHJva2UpICogdV9jb2xvckJhY2sucmdiICogdV9jb2xvckJhY2suYTtcblxuICBmbG9hdCBvcGFjaXR5ID0gMC47XG4gIG9wYWNpdHkgKz0gc3Ryb2tlO1xuICBvcGFjaXR5ICs9IHNoYXBlSW5uZXI7XG4gIG9wYWNpdHkgKz0gKDEuIC0gb3BhY2l0eSkgKiB1X2NvbG9yQmFjay5hO1xuXG4gIGZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xufVxuYDtcbmNvbnN0IERvdEdyaWRTaGFwZXMgPSB7XG4gIGNpcmNsZTogMCxcbiAgZGlhbW9uZDogMSxcbiAgc3F1YXJlOiAyLFxuICB0cmlhbmdsZTogM1xufTtcbmV4cG9ydCB7XG4gIERvdEdyaWRTaGFwZXMsXG4gIGRvdEdyaWRGcmFnbWVudFNoYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvdC1ncmlkLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/dot-grid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/vertex-shader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertexShaderSource: () => (/* binding */ vertexShaderSource)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize, vec2 maxBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize, maxBoxSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_objectHelperBox = uv;\n    v_objectHelperBox *= objectWorldScale;\n    v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize, maxBoxSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_responsiveHelperBox = uv;\n    v_responsiveHelperBox *= responsiveBoxScale;\n    v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize, maxBoxSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_patternHelperBox = uv;\n    v_patternHelperBox *= patternBoxScale;\n    v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n}`;\n\n//# sourceMappingURL=vertex-shader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUdDO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL3lvZ2VzaC9Eb2N1bWVudHMvWW9nZXNoSzM0LmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzQgYV9wb3NpdGlvbjtcblxudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9waXhlbFJhdGlvO1xuXG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWDtcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5ZO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRIZWlnaHQ7XG51bmlmb3JtIGZsb2F0IHVfZml0O1xuXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XG51bmlmb3JtIGZsb2F0IHVfcm90YXRpb247XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WDtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRZO1xuXG51bmlmb3JtIGZsb2F0IHVfcHhTaXplO1xuXG5vdXQgdmVjMiB2X29iamVjdFVWO1xub3V0IHZlYzIgdl9vYmplY3RCb3hTaXplO1xub3V0IHZlYzIgdl9vYmplY3RIZWxwZXJCb3g7XG5cbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZVVWO1xub3V0IHZlYzIgdl9yZXNwb25zaXZlQm94U2l6ZTtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUhlbHBlckJveDtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZTtcblxub3V0IHZlYzIgdl9wYXR0ZXJuVVY7XG5vdXQgdmVjMiB2X3BhdHRlcm5Cb3hTaXplO1xub3V0IHZlYzIgdl9wYXR0ZXJuSGVscGVyQm94O1xuXG4vLyAjZGVmaW5lIEFERF9IRUxQRVJTXG5cbnZlYzMgZ2V0Qm94U2l6ZShmbG9hdCBib3hSYXRpbywgdmVjMiBnaXZlbkJveFNpemUsIHZlYzIgbWF4Qm94U2l6ZSkge1xuICB2ZWMyIGJveCA9IHZlYzIoMC4pO1xuICAvLyBmaXQgPSBub25lXG4gIGJveC54ID0gYm94UmF0aW8gKiBtaW4oZ2l2ZW5Cb3hTaXplLnggLyBib3hSYXRpbywgZ2l2ZW5Cb3hTaXplLnkpO1xuICBmbG9hdCBub0ZpdEJveFdpZHRoID0gYm94Lng7XG4gIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBmaXQgPSBjb250YWluXG4gICAgYm94LnggPSBib3hSYXRpbyAqIG1pbihtYXhCb3hTaXplWzBdIC8gYm94UmF0aW8sIG1heEJveFNpemVbMV0pO1xuICB9IGVsc2UgaWYgKHVfZml0ID09IDIuKSB7IC8vIGZpdCA9IGNvdmVyXG4gICAgYm94LnggPSBib3hSYXRpbyAqIG1heChtYXhCb3hTaXplWzBdIC8gYm94UmF0aW8sIG1heEJveFNpemVbMV0pO1xuICB9XG4gIGJveC55ID0gYm94LnggLyBib3hSYXRpbztcbiAgcmV0dXJuIHZlYzMoYm94LCBub0ZpdEJveFdpZHRoKTtcbn1cblxudm9pZCBtYWluKCkge1xuICBnbF9Qb3NpdGlvbiA9IGFfcG9zaXRpb247XG5cbiAgdmVjMiB1diA9IGdsX1Bvc2l0aW9uLnh5ICogLjU7XG4gIHZlYzIgYm94T3JpZ2luID0gdmVjMiguNSAtIHVfb3JpZ2luWCwgdV9vcmlnaW5ZIC0gLjUpO1xuICB2ZWMyIGdpdmVuQm94U2l6ZSA9IHZlYzIodV93b3JsZFdpZHRoLCB1X3dvcmxkSGVpZ2h0KTtcbiAgZ2l2ZW5Cb3hTaXplID0gbWF4KGdpdmVuQm94U2l6ZSwgdmVjMigxLikpICogdV9waXhlbFJhdGlvO1xuICB2ZWMyIG1heEJveFNpemUgPSB2ZWMyKG1heCh1X3Jlc29sdXRpb24ueCwgZ2l2ZW5Cb3hTaXplLngpLCBtYXgodV9yZXNvbHV0aW9uLnksIGdpdmVuQm94U2l6ZS55KSk7XG4gIGZsb2F0IHIgPSB1X3JvdGF0aW9uICogMy4xNDE1OTI2NTM1ODk3OTMyMzg0NiAvIDE4MC47XG4gIG1hdDIgZ3JhcGhpY1JvdGF0aW9uID0gbWF0Mihjb3MociksIHNpbihyKSwgLXNpbihyKSwgY29zKHIpKTtcbiAgdmVjMiBncmFwaGljT2Zmc2V0ID0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGdyYXBoaWMgb2JqZWN0cyB3aXRoIGZpeGVkIHJhdGlvXG4gIC8vIChjdXJyZW50bHkgc3VwcG9ydHMgb25seSByYXRpbyA9IDEpXG5cbiAgZmxvYXQgZml4ZWRSYXRpbyA9IDEuO1xuICB2ZWMyIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICk7XG5cbiAgdl9vYmplY3RCb3hTaXplID0gZ2V0Qm94U2l6ZShmaXhlZFJhdGlvLCBmaXhlZFJhdGlvQm94R2l2ZW5TaXplLCBtYXhCb3hTaXplKS54eTtcbiAgdmVjMiBvYmplY3RXb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9vYmplY3RCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICAgIHZfb2JqZWN0SGVscGVyQm94ID0gdXY7XG4gICAgdl9vYmplY3RIZWxwZXJCb3ggKj0gb2JqZWN0V29ybGRTY2FsZTtcbiAgICB2X29iamVjdEhlbHBlckJveCArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9vYmplY3RVViA9IHV2O1xuICB2X29iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gIHZfb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gIHZfb2JqZWN0VVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgdl9vYmplY3RVViAvPSB1X3NjYWxlO1xuICB2X29iamVjdFVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9vYmplY3RVVjtcblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGdyYXBoaWMgb2JqZWN0cyB3aXRoIGVpdGhlciBnaXZlbkJveFNpemUgcmF0aW8gb3IgY2FudmFzIHJhdGlvLlxuICAvLyBGdWxsLXNjcmVlbiBtb2RlIGF2YWlsYWJsZSB3aXRoIHVfd29ybGRXaWR0aCA9IHVfd29ybGRIZWlnaHQgPSAwXG5cbiAgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplID0gdmVjMihcbiAgICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuICBmbG9hdCByZXNwb25zaXZlUmF0aW8gPSB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueCAvIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZS55O1xuICB2X3Jlc3BvbnNpdmVCb3hTaXplID0gZ2V0Qm94U2l6ZShyZXNwb25zaXZlUmF0aW8sIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZSwgbWF4Qm94U2l6ZSkueHk7XG4gIHZlYzIgcmVzcG9uc2l2ZUJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9yZXNwb25zaXZlQm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggPSB1djtcbiAgICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICAgIHZfcmVzcG9uc2l2ZUhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocmVzcG9uc2l2ZUJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X3Jlc3BvbnNpdmVVViA9IHV2O1xuICB2X3Jlc3BvbnNpdmVVViAqPSByZXNwb25zaXZlQm94U2NhbGU7XG4gIHZfcmVzcG9uc2l2ZVVWICs9IGJveE9yaWdpbiAqIChyZXNwb25zaXZlQm94U2NhbGUgLSAxLik7XG4gIHZfcmVzcG9uc2l2ZVVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gIHZfcmVzcG9uc2l2ZVVWIC89IHVfc2NhbGU7XG4gIHZfcmVzcG9uc2l2ZVVWLnggKj0gcmVzcG9uc2l2ZVJhdGlvO1xuICB2X3Jlc3BvbnNpdmVVViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfcmVzcG9uc2l2ZVVWO1xuICB2X3Jlc3BvbnNpdmVVVi54IC89IHJlc3BvbnNpdmVSYXRpbztcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBwYXR0ZXJuc1xuICAvLyAodHJlYXRpbmcgZ3JhcGhpY3MgYXMgYSBpbWFnZSB1X3dvcmxkV2lkdGggeCB1X3dvcmxkSGVpZ2h0IHNpemUpXG5cbiAgZmxvYXQgcGF0dGVybkJveFJhdGlvID0gZ2l2ZW5Cb3hTaXplLnggLyBnaXZlbkJveFNpemUueTtcbiAgdmVjMiBwYXR0ZXJuQm94R2l2ZW5TaXplID0gdmVjMihcbiAgICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuICBwYXR0ZXJuQm94UmF0aW8gPSBwYXR0ZXJuQm94R2l2ZW5TaXplLnggLyBwYXR0ZXJuQm94R2l2ZW5TaXplLnk7XG5cbiAgdmVjMyBib3hTaXplRGF0YSA9IGdldEJveFNpemUocGF0dGVybkJveFJhdGlvLCBwYXR0ZXJuQm94R2l2ZW5TaXplLCBtYXhCb3hTaXplKTtcbiAgdl9wYXR0ZXJuQm94U2l6ZSA9IGJveFNpemVEYXRhLnh5O1xuICBmbG9hdCBwYXR0ZXJuQm94Tm9GaXRCb3hXaWR0aCA9IGJveFNpemVEYXRhLno7XG4gIHZlYzIgcGF0dGVybkJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9wYXR0ZXJuQm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICB2X3BhdHRlcm5IZWxwZXJCb3ggPSB1djtcbiAgICB2X3BhdHRlcm5IZWxwZXJCb3ggKj0gcGF0dGVybkJveFNjYWxlO1xuICAgIHZfcGF0dGVybkhlbHBlckJveCArPSBib3hPcmlnaW4gKiAocGF0dGVybkJveFNjYWxlIC0gMS4pO1xuICAjZW5kaWZcblxuICB2X3BhdHRlcm5VViA9IHV2O1xuICB2X3BhdHRlcm5VViArPSBncmFwaGljT2Zmc2V0IC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW47XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbiAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgKj0gdV9yZXNvbHV0aW9uLnh5O1xuICB2X3BhdHRlcm5VViAvPSB1X3BpeGVsUmF0aW87XG4gIGlmICh1X2ZpdCA+IDAuKSB7XG4gICAgdl9wYXR0ZXJuVVYgKj0gKHBhdHRlcm5Cb3hOb0ZpdEJveFdpZHRoIC8gdl9wYXR0ZXJuQm94U2l6ZS54KTtcbiAgfVxuICB2X3BhdHRlcm5VViAvPSB1X3NjYWxlO1xuICB2X3BhdHRlcm5VViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfcGF0dGVyblVWO1xuICB2X3BhdHRlcm5VViArPSBib3hPcmlnaW4gLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWIC09IGJveE9yaWdpbjtcbiAgLy8geDEwMCBpcyBhIGRlZmF1bHQgbXVsdGlwbGllciBiZXR3ZWVuIHZlcnRleCBhbmQgZnJhZ21hbnQgc2hhZGVyc1xuICAvLyB3ZSB1c2UgaXQgdG8gYXZvaWQgVVYgcHJlc2lzaW9uIGlzc3Vlc1xuICB2X3BhdHRlcm5VViAqPSAuMDE7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbn1gO1xuZXhwb3J0IHtcbiAgdmVydGV4U2hhZGVyU291cmNlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVydGV4LXNoYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\n");

/***/ })

};
;